---
title: "Multiomics_script_WIP"
author: "JY"
date: "2025-03-04"
output: html_document
editor_options: 
  chunk_output_type: console
---

Input:
- RNA and ATAC data from 10x Genomics Multiome experiment
- 4 experimental conditions: PTZ 1hr, PTZ 24hr, SAL 1hr, SAL 24hr


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r Library setup, echo=TRUE, message=TRUE, warning=T, error=TRUE}
# Parallelization for process
library(future)
options(future.globals.maxSize = 128000 * 1024 ^ 2)  # Increase memory limit
library(parallel)  # Base R parallelization package

# Single-cell analysis (scRNA-seq & scATAC-seq)
library(Signac)         # scATAC-seq analysis
library(Seurat)         # scRNA-seq analysis
library(sctransform)    # Normalization for scRNA-seq
library(DoubletFinder)  # Detects doublets in single-cell datasets
library(scCustomize)    # Enhances Seurat visualization and analysis
library(SingleCellExperiment)

# Data manipulation & utilities
library(tidyverse)   # tidyr, dplyr, readr, purr, stringr, ggplot2, tibble, forcats, ludridate
library(data.table)  # High-speed alternative to data frames
library(Matrix)      # Sparse matrix operations (important for single-cell data)
library(jsonlite)

# Visualization & Plotting
library(ggplot2)          # Core visualization package
library(patchwork)        # Arrange multiple ggplots
library(cowplot)          # Additional ggplot utilities
library(ggrepel)          # Prevents text overlap in plots
library(ggvenn)           # Venn diagrams
library(ggVennDiagram)    # Another Venn diagram package
library(VennDiagram)      # Classic Venn diagrams
library(ggpubr)           # Publication-ready plots
library(ComplexHeatmap)   # Advanced heatmaps
library(circlize)         # Circular visualizations
library(pheatmap)         # Heatmaps
library(RColorBrewer)     # Color palettes
library(fields)           # Spatial plots and interpolation
library(enrichplot)       # Visualization for enrichment analysis
library(eulerr)           # Euler diagrams
library(gridExtra)        # Arrange multiple plots
library(corrplot)         # Correlation heatmaps
library(viridis)          # Colorblind-friendly palettes
library(scales)           # scale plot
library(EnhancedVolcano)
library(RColorBrewer)

# Clustering & Dimensionality Reduction
library(clustree)  # Clustering trees for resolution selection
library(igraph)    # Graph-based clustering

# Differential Expression & Statistical Analysis
library(DESeq2)   # Differential expression analysis
library(MAST)
library(rstatix)  # Statistical functions for ggplot2
library(ROCR)     # ROC curves for model evaluation

# Gene Ontology & Pathway Analysis
library(clusterProfiler)  # Functional enrichment analysis
library(org.Mm.eg.db)     # Mouse genome annotations
library(DOSE)             # Disease ontology enrichment
library(rrvgo)            # Reduce GO terms redundancy
library(treemap)          # Tree visualization for GO terms
library(AnnotationDbi)    # Database interface
library(GO.db)            # Gene Ontology database
library(ontologyIndex)    # General ontology functions
library(fgsea)            # fGSEA analysis
library(msigdbr)          # ref for fGSEA

# Pseudotime trajectory analysis
library(slingshot)
library(tradeSeq)

# Genomics & Motif Analysis
library(BSgenome.Mmusculus.UCSC.mm10)  # Mouse genome
library(rtracklayer)                   # Import/export genomic data
library(JASPAR2020)                    # Transcription factor motifs
library(TFBSTools)                      # Analyze transcription factor binding sites

# File Handling & Misc
library(openxlsx)  # Read/write Excel files
dyn.load("/igm/apps/hdf5/hdf5-1.12.1/lib/libhdf5_hl.so.200")  # Load HDF5 library
library(hdf5r)     # HDF5 file format for large datasets

# Interactive Applications
library(shiny)  # Web-based interactive applications
```

```{r environment setup, echo=TRUE, message=TRUE, warning=T, error=TRUE}
# Set random seed for reproducibility
set.seed(42)
```

```{r Folder path set, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Output folder path set
output_dir_base <-"~/PTZ_ATAC_scRNA_072024/WIP/FullScript_test"

# Set base input folder directory files.
input_dir <- "~/PTZ_ATAC_scRNA_072024/File"

dir.create(output_dir_base, recursive = TRUE, showWarnings = FALSE)
```

```{r Sample id set, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Set sample ID
Samples <- c("PTZ_1hr", "PTZ_24hr", "SAL_1hr", "SAL_24hr") 
```

```{r H5 file loading, echo=TRUE, message=TRUE, warning=T, error=TRUE}
# Load h5 files.
PTZ_1hr <- Read10X_h5(file.path(input_dir, Samples[1], "outs/filtered_feature_bc_matrix.h5"))
PTZ_24hr <-Read10X_h5(file.path(input_dir, Samples[2], "/outs/filtered_feature_bc_matrix.h5"))
SAL_1hr <-Read10X_h5(file.path(input_dir, Samples[3], "/outs/filtered_feature_bc_matrix.h5"))
SAL_24hr <-Read10X_h5(file.path(input_dir, Samples[4], "/outs/filtered_feature_bc_matrix.h5"))
```

```{r Create Seurat object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Create Seurat objects from 10x data
  # Parameters:
  # - counts: Gene expression matrix from 10X h5 file 
  # - assay: Set RNA as the default assay type
  # - min.cells: Only keep genes expressed in at least 3 cells
  # - min.features: Only keep cells with at least 200 genes expressed
  # - max.RNA - Upper threshold for RNA counts to filter doublets (default: 25000)
  # - min.RNA - Lower threshold for RNA counts to filter empty droplets (default: 1000)
  # - meta.data: Import cell metadata from the per_barcode_metrics.csv file
  # - header = TRUE indicates the CSV has column names
  # - row.names = 1 indicates the first column is used as row names

PTZ_1hr <- CreateSeuratObject(counts = PTZ_1hr$`Gene Expression`,
                              assay = "RNA",
                              project = "PTZ_1hr", # Sets orig.ident for all cells in this object
                              min.cells = 3,
                              min.features = 200,
                              meta.data = read.csv(file = file.path(input_dir, Samples[1], "outs/per_barcode_metrics.csv"), header = TRUE, row.names = 1))

PTZ_24hr <- CreateSeuratObject(counts = PTZ_24hr$`Gene Expression`,
                               assay = "RNA",
                               project = "PTZ_24hr", # Sets orig.ident for all cells in this object
                               min.cells = 3,
                               min.features = 200,
                               meta.data = read.csv(file = file.path(input_dir, Samples[2], "outs/per_barcode_metrics.csv"), header = TRUE, row.names = 1))

SAL_1hr <- CreateSeuratObject(counts = SAL_1hr$`Gene Expression`,
                              assay = "RNA",
                              project = "SAL_1hr", # Sets orig.ident for all cells in this object
                              min.cells = 3,
                              min.features = 200,
                              meta.data = read.csv(file = file.path(input_dir, Samples[3], "outs/per_barcode_metrics.csv"), header = TRUE, row.names = 1))

SAL_24hr <- CreateSeuratObject(counts = SAL_24hr$`Gene Expression`,
                               assay = "RNA",
                               project = "SAL_24hr", # Sets orig.ident for all cells in this object
                               min.cells = 3,
                               min.features = 200,
                               meta.data = read.csv(file = file.path(input_dir, Samples[4], "outs/per_barcode_metrics.csv"), header = TRUE, row.names = 1))
```

```{r Subset the object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# 2. Filter by QC metrics (nCount, nFeature, %MT)
  # PercentageFeatureSet calculates the fraction of counts attributed to mitochondrial genes for each cell
  # - mt.pattern - Pattern to identify mitochondrial genes (default: "^mt-"), create mitocondria gene information.

PTZ_1hr <- PercentageFeatureSet(PTZ_1hr, pattern = "^mt-", col.name = "percent_mt_rna", assay = "RNA")
PTZ_24hr <- PercentageFeatureSet(PTZ_24hr, pattern = "^mt-", col.name = "percent_mt_rna", assay = "RNA")
SAL_1hr <- PercentageFeatureSet(SAL_1hr, pattern = "^mt-", col.name = "percent_mt_rna", assay = "RNA")
SAL_24hr <- PercentageFeatureSet(SAL_24hr, pattern = "^mt-", col.name = "percent_mt_rna", assay = "RNA")

PTZ_1hr <-subset(PTZ_1hr, subset = nCount_RNA < 25000 & nCount_RNA > 1000 & percent_mt_rna < 5)
PTZ_24hr <-subset(PTZ_24hr, subset = nCount_RNA < 25000 & nCount_RNA > 1000 & percent_mt_rna < 5)
SAL_1hr <-subset(SAL_1hr, subset = nCount_RNA < 25000 & nCount_RNA > 1000 & percent_mt_rna < 5)
SAL_24hr <-subset(SAL_24hr, subset = nCount_RNA < 25000 & nCount_RNA > 1000 & percent_mt_rna < 5)
```

```{r Normalization and scale, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# 3. Normalize and scale data

# SCTransform
#   Adjusts for sequencing depth (library size).Provides normalized counts while maintaining biological variability.
#   Stabilizes the variance across genes, Identifies and prioritizes highly variable genes for analysis.
# 	Improves signal-to-noise ratio by reducing the influence of technical noise.
# 	Allows correction for technical artifacts or batch effects through regression.
  # vars.to.regress Variables to regress out (default: "percent_mt_rna") - Regress out unwanted sources of variation 
  # method Normalization method (default: "glmGamPoi")
  # return.only.var.genes Whether to keep only variable genes for downstream analysis
  # return.only.var.genes = FALSE to retain all genes in the normalized data. DEG and GO analyses typically require information from all genes, 
  # even those not classified as highly variable. but it will increase the computation time and memory usage. default is TRUE.

PTZ_1hr <-SCTransform(PTZ_1hr, method = "glmGamPoi", assay = "RNA", verbose = TRUE, vars.to.regress = c("percent_mt_rna"))
PTZ_24hr <-SCTransform(PTZ_24hr, method = "glmGamPoi", assay = "RNA", verbose = TRUE,  vars.to.regress = c("percent_mt_rna"))
SAL_1hr <-SCTransform(SAL_1hr, method = "glmGamPoi", assay = "RNA", verbose = TRUE,  vars.to.regress = c("percent_mt_rna"))
SAL_24hr <-SCTransform(SAL_24hr, method = "glmGamPoi", assay = "RNA", verbose = TRUE,  vars.to.regress = c("percent_mt_rna"))
```

```{r Demesionality reduction, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Compresses the dataset into fewer dimensions (principal components, or PCs) that capture the most variance in the data.
# Identifies patterns of variability across genes and cells.
  # n.dims Number of dimensions to use (default: 30)
  # resolution Clustering resolution (default: 0.8)
  # assay to use SCT
  # reduction.name Name for UMAP reduction (default: "umap")
  # verbose Print progress
# PCA
# Stores PCA results in the Seurat object under PTZ_1hr[["pca"]]
  #	Loadings: Contribution of each gene to each PC.
  #	Scores: Position of each cell in the PC space.
  # Eigenvalues: Variance captured by each PC.

PTZ_1hr <- RunPCA(PTZ_1hr, assay = "SCT", verbose = TRUE)
PTZ_24hr <- RunPCA(PTZ_24hr, assay = "SCT", verbose = TRUE)
SAL_1hr <- RunPCA(SAL_1hr, assay = "SCT", verbose = TRUE)
SAL_24hr <- RunPCA(SAL_24hr, assay = "SCT", verbose = TRUE)

# visualize PCs from PCA
# ElbowPlot(PTZ_1hr, ndims = 50)

# UMAP
  # pca reduction to use
PTZ_1hr <- RunUMAP(PTZ_1hr, dims = 1:30, reduction = "pca", assay = "SCT", verbose = TRUE)
PTZ_24hr <- RunUMAP(PTZ_24hr, dims = 1:30, reduction = "pca", assay = "SCT", verbose = TRUE)
SAL_1hr <- RunUMAP(SAL_1hr, dims = 1:30, reduction = "pca", assay = "SCT", verbose = TRUE)
SAL_24hr <- RunUMAP(SAL_24hr, dims = 1:30, reduction = "pca", assay = "SCT", verbose = TRUE)

# TSNE
PTZ_1hr <- RunTSNE(PTZ_1hr, dims = 1:30, reduction = "pca", assay = "SCT", verbose = TRUE)
PTZ_24hr <- RunTSNE(PTZ_24hr, dims = 1:30, reduction = "pca", assay = "SCT", verbose = TRUE)
SAL_1hr <- RunTSNE(SAL_1hr, dims = 1:30, reduction = "pca", assay = "SCT", verbose = TRUE)
SAL_24hr <- RunTSNE(SAL_24hr, dims = 1:30, reduction = "pca", assay = "SCT", verbose = TRUE)
```

```{r Sample information set, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Function to set identities
identify <- function(seurat_obj, identity) {
  seurat_obj$sample <- identity
  seurat_obj$condition <- ifelse(grepl("PTZ", identity), "PTZ", "SAL")
  seurat_obj$timepoint <- ifelse(grepl("1hr", identity), "1hr", "24hr")
  return(seurat_obj)
}

# Apply preprocessing and set identities
PTZ_1hr <- identify(PTZ_1hr, Samples[1])
PTZ_24hr <- identify(PTZ_24hr, Samples[2])
SAL_1hr <- identify(SAL_1hr, Samples[3])
SAL_24hr <- identify(SAL_24hr, Samples[4])

# Prepend group name to cell barcodes
PTZ_1hr <- RenameCells(PTZ_1hr, add.cell.id = PTZ_1hr$sample)
PTZ_24hr <- RenameCells(PTZ_24hr, add.cell.id = PTZ_24hr$sample)
SAL_1hr <- RenameCells(SAL_1hr, add.cell.id = SAL_1hr$sample)
SAL_24hr <- RenameCells(SAL_24hr, add.cell.id = SAL_24hr$sample)
```

```{r Save point - individual RNA object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
dir.create("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/RDS_mid", recursive = TRUE, showWarnings = FALSE)

saveRDS(PTZ_1hr, file.path(output_dir_base, "RDS_mid", paste0(Samples[1], ".rds")))
saveRDS(PTZ_24hr, file.path(output_dir_base, "RDS_mid", paste0(Samples[2], ".rds")))
saveRDS(SAL_1hr, file.path(output_dir_base, "RDS_mid", paste0(Samples[3], ".rds")))
saveRDS(SAL_24hr, file.path(output_dir_base, "RDS_mid", paste0(Samples[4], ".rds")))
```

```{r Reading RNA object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
PTZ_1hr <- readRDS(file.path(output_dir_base,"RDS_mid", (paste0(Samples[1] , ".rds"))))
PTZ_24hr <- readRDS(file.path(output_dir_base,"RDS_mid", (paste0(Samples[2] , ".rds"))))
SAL_1hr <- readRDS(file.path(output_dir_base,"RDS_mid", (paste0(Samples[3] , ".rds"))))
SAL_24hr <- readRDS(file.path(output_dir_base,"RDS_mid", (paste0(Samples[4] , ".rds"))))
```

```{r Integration list set, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
Samples <- c("PTZ_1hr", "PTZ_24hr", "SAL_1hr", "SAL_24hr") 
seurat_list <- list(PTZ_1hr = PTZ_1hr, PTZ_24hr = PTZ_24hr, SAL_1hr = SAL_1hr, SAL_24hr = SAL_24hr)
```

```{r Integration RNA from Seurat list, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Select features for integration
# Identifies common features (genes) across datasets that are informative for integration. 
# These features are used for anchor identification and subsequent data integration.
features <-SelectIntegrationFeatures(object.list = seurat_list, nfeatures = 3000)

# Prepare for integration
# Prepares the datasets for integration by ensuring that the same SCT model is applied to the selected features across datasets.
seurat_list <-PrepSCTIntegration(object.list = seurat_list, anchor.features = features)

# Find integration anchors
# Identifies anchors (shared cells or cell populations) across datasets based on the selected features.
anchors <- FindIntegrationAnchors(object.list = seurat_list, normalization.method = "SCT", anchor.features = features)

# Find integration anchors
# Identifies anchors (shared cells or cell populations) across datasets based on the selected features.
integrated_rna <-IntegrateData(anchorset = anchors, normalization.method = "SCT")

# Claer workspace
# rm("PTZ_1hr", "PTZ_24hr", "SAL_1hr", "SAL_24hr", "seurat_list", "anchors", "features")
```

```{r Save point - integrated RNA object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(integrated_rna, file.path(output_dir_base, "RDS_mid", paste0("integrated_rna.rds")))
```

```{r Process integrated object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# After integration, Seurat recommends using the integrated assay for dimensionality reduction and clustering to leverage the batch-corrected data.
integrated_rna <- RunPCA(integrated_rna, assay = "integrated", verbose = T)

# Visualize PCA results (optional)
# ElbowPlot(integrated_rna, ndims = 50)

#	Identify cell neighborhoods and perform clustering: 
#	Compute the k-nearest neighbor graph based on the PCA results.
#	kNN graph (RNA_nn): Represents direct neighbors of each cell.	A k-nearest neighbor graph 
#	SNN graph (RNA_snn): Shared nearest neighbor graph, used for clustering. derived from the kNN graph
integrated_rna <- FindNeighbors(integrated_rna, dims = 1:30, reduction = "pca", verbose = T, graph.name = c("RNA_nn", "RNA_snn"))

# Cluster
for (i in seq(0.4, 1.2, by = 0.1)) {
  integrated_rna <- FindClusters(integrated_rna, graph.name = "RNA_snn", resolution = i, verbose = T, cluster.name = paste0("RNA_cluster_", i))
}

# When SCTransform is run, residuals of the gene expression are stored in the "scale.data" slot of the "SCT" assay.
# PrepSCTFindMarkers ensures that the residual variance of the genes is appropriately scaled and stabilized before marker detection.
# Run PrepSCTFindMarkers after clustering and before running FindAllMarkers.
integrated_rna <- PrepSCTFindMarkers(integrated_rna, verbose = T)

# dimensional reduction
integrated_rna <- RunUMAP(integrated_rna, reduction = "pca", reduction.name = "RNA_umap", dims = 1:30, verbose = T)
integrated_rna <- RunTSNE(integrated_rna, reduction = "pca", dims = 1:30, verbose = T)
```

```{r Save point - integrated RNA, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(integrated_rna, file.path(output_dir_base, "RDS_mid", paste0("integrated_rna_processed.rds")))
```

```{r Cluster markers for integrated RNA, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# The "SCT" assay contains normalized and variance-stabilized data suitable for identifying differentially expressed genes between clusters.
# The "integrated" assay is batch-corrected for alignment and not designed for marker detection as it may suppress biological variation in favor of alignment.
# only.pos = TRUE: Returns only positive markers (regions more accessible in the cluster).
# min.pct: Minimum fraction of cells expressing the feature in the cluster.
# logfc.threshold: Minimum log fold-change required to call a feature significant.
DefaultAssay(integrated_rna) <- "SCT"

marker_results <- list()
for (i in seq(0.4, 1.2, by = 0.1)) {
  Idents(integrated_rna) <- integrated_rna[[paste0('RNA_cluster_', i)]][,1]
  marker_results[[paste0("RNA_cluster_", i)]] <- FindAllMarkers(integrated_rna, 
                                                                assay = "SCT", 
                                                                slot = "data", 
                                                                only.pos = TRUE, 
                                                                min.pct = 0.25, 
                                                                logfc.threshold = 0.25)
}
```

```{r Save point - integrated RNA markers, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
dir.create("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/csv", recursive = TRUE, showWarnings = FALSE)

for (name in names(marker_results)) {
  write.csv(marker_results[[name]], file = paste0("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/csv/", name, "_markers.csv"), row.names = FALSE)
}
```

```{r ATAC file path, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Define paths for ATAC data
peak_beds <- c(
  file.path(input_dir, Samples[1], "outs/atac_peaks.bed"),
  file.path(input_dir, Samples[2], "outs/atac_peaks.bed"),
  file.path(input_dir, Samples[3], "outs/atac_peaks.bed"),
  file.path(input_dir, Samples[4], "outs/atac_peaks.bed"))

frag_paths <- c(
  file.path(input_dir, Samples[1], "outs/atac_fragments.tsv.gz"),
  file.path(input_dir, Samples[2], "outs/atac_fragments.tsv.gz"),
  file.path(input_dir, Samples[3], "outs/atac_fragments.tsv.gz"),
  file.path(input_dir, Samples[4], "outs/atac_fragments.tsv.gz"))
```

```{r Merge ATAC function, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# function from Matt Cannon ---rrrsingglecellepxp library
# peak_beds List of paths to peak bed files
# min_peak_width Minimum width of peaks to include
# max_peak_width Maximum width of peaks to include  
# frag_paths List of paths to fragment files
# cell_ids Sample IDs for labeling
# n_regions_simul Number of regions to process simultaneously
# threads Number of parallel threads to use
# return Merged Seurat object with ATAC data
merge_atac_id <- function(peak_beds,
                          min_peak_width = 20,
                          max_peak_width = 10000,
                          frag_paths,
                          cell_ids,
                          n_regions_simul = 2000,
                          threads = 1) {
  message("Make sure that paths and cell_ids are in the same order")
  message("peak_beds: ", paste(peak_beds, sep = " "))
  message("frag_paths: ", paste(frag_paths, sep = " "))
  message("cell_ids: ", paste(cell_ids, sep = " "))
  
  # read peaks into a dataframe and reduce them
  reduced_peaks <- readr::read_tsv(peak_beds,
                                   comment = "#",
                                   col_names = c("chr", "start", "end"),
                                   show_col_types = FALSE) %>%
    GenomicRanges::makeGRangesFromDataFrame() %>%
    Signac::reduce()
  
  # filter out peaks that are too small or too large
  reduced_peaks <- reduced_peaks[
    reduced_peaks@ranges@width >= min_peak_width &
      reduced_peaks@ranges@width <= max_peak_width
  ]
  
  # Function to get fragment files, count and make Seurat object
  make_chrom_seurat <- function(i) {
    frags <- Signac::CreateFragmentObject(path = frag_paths[[i]])
    
    counts <- Signac::FeatureMatrix(fragments = frags,
                                    features = reduced_peaks,
                                    process_n = n_regions_simul)
    
    obj <- Signac::CreateChromatinAssay(counts = counts,
                                        fragments = frags) %>%
      SeuratObject::CreateSeuratObject(assay = "ATAC")
    
    return(obj)
  }
  
  # Use apply to make the Seurat objects and then merge them
  obj_list <-
    parallel::mclapply(seq_len(length(frag_paths)),
                       make_chrom_seurat,
                       mc.cores = threads)
  
  seurat_obj <- merge(x = obj_list[[1]],
                      y = obj_list[-1],
                      add.cell.ids = cell_ids)
  
  return(seurat_obj)
}
```

```{r Excute ATAC merging function, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
merged_atac <- merge_atac_id(peak_beds = peak_beds, frag_paths = frag_paths, cell_ids = Samples, n_regions_simul = 100000, threads = 3)
```

```{r Save point - ATAC merged object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(merged_atac,file.path(output_dir_base, "RDS_mid", "merged_atac.rds"))
```

```{r Add annotation to ATAC object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Convert gene_type to gene_biotype for compatibility with downstream tools.
mm10 <-import("/igm/apps/10X_chromium/refdata-cellranger-arc-mm10-2020-A-2.0.0/genes/genes.gtf.gz")

# Genome assembly
genome(mm10) <- "mm10"
seqlevelsStyle(mm10) <- "UCSC"
mm10$gene_biotype <- mm10$gene_type
annotations <- mm10

# add annotation
DefaultAssay(merged_atac) <- "ATAC"
Annotation(merged_atac) <- annotations

# Claer workspace
rm("i", "name","mm10", "annotations", "peak_beds", "frag_paths")
```

```{r Save point - ATAC annotation, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Save RDS
saveRDS(annotation, file.path(output_dir_base, "RDS_mid", "atac_annotation.rds"))
saveRDS(merged_atac,file.path(output_dir_base, "RDS_mid", "merged_atac_annotated.rds"))
```

```{r ATAC QC process, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Compute QC metrics
# nucleosome_signal: Indicator of chromatin accessibility.
# TSS.enrichment: Indicator of transcriptional activity.
merged_atac <- NucleosomeSignal(merged_atac)
merged_atac <- TSSEnrichment(merged_atac, fast = FALSE)
merged_atac$high_tss <- ifelse(merged_atac$TSS.enrichment > 2, "High", "Low")
merged_atac$nucleosome_group <- ifelse(merged_atac$nucleosome_signal > 4,paste0("NS > ", 4), paste0("NS < ", 4))

# nCount_ATAC: Total number of ATAC reads per cell.
merged_atac <- subset(merged_atac, subset = nCount_ATAC < 100000 & nCount_ATAC > 1000 & nucleosome_signal < 2 & TSS.enrichment > 2)
```

```{r Save point - ATAC QC, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(merged_atac,file.path(output_dir_base, "RDS_mid", "merged_atac_annotated_filtered.rds"))
```

```{r ATAC Normaization and Dimensional reduction, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Raw ATAC data is transformed using RunTFIDF and FindTopFeatures.
#	Dimensionality reduction is performed using RunSVD, creating the lsi reduction.
#	UMAP, clustering, and neighbors rely on the lsi reduction.

DefaultAssay(merged_atac) <- "ATAC"

# Normalizes ATAC-seq data using Term Frequency-Inverse Document Frequency (TF-IDF) - Dimensionality Reduction, which adjusts for the varying accessibility of regions across cells.
# This step is crucial for focusing on biologically meaningful peaks.
merged_atac <- RunTFIDF(merged_atac) # Normalize data

# Selects the most variable peaks for downstream analysis, improving computational efficiency and accuracy.
merged_atac <- FindTopFeatures(merged_atac, min.cutoff = 10) # Select features

# Performs Latent Semantic Indexing (LSI), a dimensionality reduction technique tailored for sparse data like ATAC-seq.
merged_atac <- RunSVD(merged_atac) # Generate 'lsi' reduction

# Builds k-nearest neighbor (kNN) and shared nearest neighbor (SNN) graphs based on LSI dimensions. The ATAC_snn graph is used for clustering.
merged_atac <- FindNeighbors(merged_atac, reduction = "lsi", dims = 2:30, graph.name = c("ATAC_nn", "ATAC_snn"), verbose = T)

# Computes a UMAP embedding for visualization of clusters.Uses the LSI dimensions for input..
merged_atac <- RunUMAP(merged_atac, reduction.name = "ATAC_umap", reduction = "lsi", dims = 1:30, verbose = T)
```

```{r Save pont - ATAC process, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(merged_atac,file.path(output_dir_base, "RDS_mid", "merged_atac_annotated_filtered_processed.rds"))

```

```{r ATAC cluster, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Cluster
for (i in seq(0.4, 1.2, by = 0.1)) {
  merged_atac <- FindClusters(merged_atac, graph.name = "ATAC_snn", resolution = i, verbose = T, cluster.name = paste0("ATAC_cluster_", i))
}
```

```{r Save pont - ATAC process 2, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(merged_atac,file.path(output_dir_base, "RDS_mid", "merged_atac_annotated_filtered_processed.rds"))
```

```{r ATAC cluster markers, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
DefaultAssay(merged_atac) <- "ATAC"

marker_results_atac <- list()
for (i in seq(0.4, 1.2, by = 0.1)) {
  Idents(merged_atac) <- merged_atac[[paste0('ATAC_cluster_', i)]][,1]
  marker_results_atac[[paste0("ATAC_cluster_", i)]] <- FindAllMarkers(merged_atac, 
                                                                assay = "ATAC", 
                                                                slot = "data", 
                                                                only.pos = TRUE, 
                                                                min.pct = 0.25, 
                                                                logfc.threshold = 0.25)
}
```

```{r Save point - ATAC markers, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
for (name in names(marker_results_atac)) {
  write.csv(marker_results_atac[[name]], file = paste0("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/csv/", name, "_markers.csv"), row.names = FALSE)
}
```

```{r Combining ATAC and RNA , extractign common cells, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# integrated_rna <- readRDS("~/PTZ_ATAC_scRNA_072024/WIP/Mid_final_test/RDS_mid/integrated_rna_processed.rds")
# merged_atac <- readRDS("~/PTZ_ATAC_scRNA_072024/WIP/Mid_final_test/RDS_mid/merged_atac_annotated_filtered_processed.rds")

# Common cell find
common_cells <- intersect(colnames(integrated_rna), colnames(merged_atac))

# Get common RNA Date
integrated_rna <- integrated_rna[, common_cells]

# Get common ATAC data
merged_atac <- merged_atac[, common_cells]

# Create ATAC column in RNA seurat object
integrated_rna[["ATAC"]] <- merged_atac[["ATAC"]]

# Get RNA and ATAC meta data
atac_meta <- merged_atac@meta.data
rna_meta <- integrated_rna@meta.data

# Identify ATAC-specific metadata columns
atac_specific_cols <-setdiff(colnames(atac_meta), colnames(rna_meta))

# Add ATAC-specific metadata to RNA object
for (col in atac_specific_cols) {
  integrated_rna[[col]] <- atac_meta[[col]]}

# Rename the object
combined_merged <- integrated_rna

# Claer workspace
rm("integrated_rna", "merged_atac", "atac_meta", "rna_meta", "common_cells", "atac_specific_cols")
```

```{r Save pont - combined object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(combined_merged, file.path(output_dir_base, "RDS_mid", "combined_merged.rds"))
```

```{r Combine summary, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Generate summary statistics
summary_stats <- combined_merged@meta.data %>%
  dplyr::group_by(orig.ident, condition, timepoint) %>%
  dplyr::summarize(Cell_Count = dplyr::n(), ) %>% # Count the number of rows (cells) in each group
  dplyr::ungroup() %>%
  dplyr::rename(Group = orig.ident, Condition = condition, Timepoint = timepoint)

# save
write.csv(summary_stats, file.path(output_dir_base, "csv", "RNA_ATAC_merge_summary.csv"), row.names = FALSE)
```

```{r combiend object process, normalization and dimentionality reduction, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# After combining, re-normalize the RNA and ATAC data to account for any differences introduced by subsetting.
DefaultAssay(combined_merged) <- "ATAC"
combined_merged <- RunTFIDF(combined_merged)  # Normalize raw ATAC data
combined_merged <- FindTopFeatures(combined_merged, min.cutoff = 10) # Select variable peaks
combined_merged <- RunSVD(combined_merged) # Dimensionality reduction (creates "lsi")
saveRDS(combined_merged, file.path(output_dir_base, "RDS_mid", "combined_merged_processed.rds"))

# normalization
DefaultAssay(combined_merged) <- "RNA"
combined_merged <- SCTransform(combined_merged, method = "glmGamPoi", assay = "RNA",  vars.to.regress = c("percent_mt_rna"), vst.flavor = "v2", verbose = TRUE)
# DefaultAssay(combined_merged) <- "SCT"
combined_merged <- RunPCA(combined_merged, verbose = TRUE) # Dimensionality reduction (creates "pca")

# Find Neighbors and UMAP for RNA
combined_merged <- FindNeighbors(combined_merged, dims = 1:30, assay = "SCT", reduction = "pca",  graph.name = c("RNA_integrated_nn", "RNA_integrated_snn"), verbose = T)
combined_merged <- RunUMAP(combined_merged, reduction.name = "RNA_integrated_umap",  assay = "SCT", reduction = "pca", dims = 1:30, verbose = T)

# Find Neighbors and UMAP for ATAC
combined_merged <- FindNeighbors(combined_merged, dims = 2:30,  assay = "ATAC", reduction = "lsi",  graph.name = c("ATAC_integrated_nn", "ATAC_integrated_snn"), verbose = T)
combined_merged <- RunUMAP(combined_merged, reduction.name = "ATAC_integrated_umap",  assay = "ATAC", reduction = "lsi", dims = 2:30, verbose = T)
```

```{r Save point - processed combined object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(combined_merged, file.path(output_dir_base, "RDS_mid", "combined_merged_processed.rds"))
```

```{r Find clusters, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
for (i in seq(0.4, 1.2, by = 0.1)) {
  combined_merged <- FindClusters(combined_merged, graph.name = "RNA_integrated_snn", resolution = i, verbose = T, cluster.name = paste0("RNA_integrated_cluster_", i))
  combined_merged <- FindClusters(combined_merged, graph.name = "ATAC_integrated_snn", resolution = i, verbose = T, cluster.name = paste0("ATAC_integrated_cluster_", i))
}
```

```{r Save point - after cluster process, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(combined_merged, file.path(output_dir_base, "RDS_mid", "combined_merged_processed.rds"))
```

```{r Find markers from cluster, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
combined_merged <- PrepSCTFindMarkers(combined_merged)

marker_results_combined <- list()
for (i in seq(0.4, 1.2, by = 0.1)) {
  Idents(combined_merged) <- combined_merged[[paste0('ATAC_integrated_cluster_', i)]][,1]
  marker_results_combined[[paste0("RNA_integrated_cluster_", i)]] <- FindAllMarkers(combined_merged, 
                                                                assay = "ATAC", 
                                                                slot = "data", 
                                                                only.pos = TRUE, 
                                                                min.pct = 0.25, 
                                                                logfc.threshold = 0.25,
                                                                graph.name = "RNA_integrated_snn")
  
  Idents(combined_merged) <- combined_merged[[paste0('RNA_integrated_cluster_', i)]][,1]
  marker_results_combined[[paste0("ATAC_integrated_cluster_", i)]] <- FindAllMarkers(combined_merged, 
                                                                assay = "SCT", 
                                                                slot = "data", 
                                                                only.pos = TRUE, 
                                                                min.pct = 0.25, 
                                                                logfc.threshold = 0.25,
                                                                graph.name = "ATAC_integrated_snn")
}
```

```{r Save point - markers, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
for (name in names(marker_results_combined)) {
  write.csv(marker_results_combined[[name]], file = paste0("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/csv/", name, "_markers.csv"), row.names = FALSE)
}
```

```{r Multimodal neighbor calculation, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# build a joint neighbor graph using both assays
# The FindMultiModalNeighbors step focuses on integrating RNA and ATAC modalities into a shared neighbor graph but does not modify the residual variance or scaled data in the "SCT" assay.
# integrates RNA (PCA reduction) and ATAC (LSI reduction) data into a shared nearest-neighbor graph.

combined_merged <- FindMultiModalNeighbors(object = combined_merged, 
                                           reduction.list = list("pca", "lsi"), # reduction.list: Specifies RNA and ATAC reductions ("pca" for RNA, "lsi" for ATAC).
                                           dims.list = list(1:30, 2:30), # dims.list: Defines the number of dimensions to use for each modality.
                                           knn.graph.name = "Multimodal_wknn", # Multimodal_wknn: Weighted k-nearest neighbor graph.
                                           snn.graph.name = "Multimodal_wsnn", # Multimodal_wsnn: Shared nearest neighbor (SNN) graph.
                                           weighted.nn.name = "Multimodal_weighted.nn", # Multimodal_weighted.nn: Final multi-modal neighbor graph.
                                           modality.weight.name = c("Multimodal_RNA_weight", "Multimodal_ATAC_weight"), # modality.weight.name: Adds weights to indicate the relative contribution of RNA and ATAC.
                                           verbose = TRUE)

```

```{r Multimodal neighbor UMAP, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# build a joint UMAP visualization
# Creates a UMAP embedding based on the joint multi-modal neighbor graph ("Multimodal_weighted.nn").
combined_merged <- RunUMAP(object = combined_merged,
                           nn.name = "Multimodal_weighted.nn", # nn.name: Uses the joint neighbor graph.
                           # UMAP embedding for multi-modal neighbors does not rely on the data in the SCT assay 
                           # but instead leverages the Multimodal_weighted.nn graph. 
                           # Hence, the choice of assay (SCT or ATAC) does not impact the multi-modal UMAP embedding.
                           verbose = TRUE, 
                           reduction.name = "Multi_umap")
```

```{r Save point - Multimodal integration, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(combined_merged, file.path(output_dir_base, "RDS_mid", "combined_merged_processed_multimodal.rds"))
```

```{r Multimodal cluster, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
for (i in seq(0.4, 1.2, by = 0.1)) {
  combined_merged <- FindClusters(combined_merged, graph.name = "Multimodal_wsnn", resolution = i, verbose = T, cluster.name = paste0("Multimodal_cluster_", i))
}
```

```{r Save point - Multimodal cluster, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(combined_merged, file.path(output_dir_base, "RDS_mid", "combined_merged_processed_multimodal_processed.rds"))
```

```{r Multimodal markers, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
marker_results_multi <- list()
for (i in seq(0.4, 1.2, by = 0.1)) {
  Idents(combined_merged) <- combined_merged[[paste0('Multimodal_cluster_', i)]][,1]
  marker_results_multi[[paste0("Multimodal_cluster_", i)]] <- FindAllMarkers(combined_merged, 
                                                                assay = "SCT", 
                                                                slot = "data", 
                                                                only.pos = TRUE, 
                                                                min.pct = 0.25, 
                                                                logfc.threshold = 0.25)
}
for (name in names(marker_results_multi)) {
  write.csv(marker_results_multi[[name]], file = paste0("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/csv/", name, "_markers.csv"), row.names = FALSE)
}
```

```{r Save point - multimodal markers, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
for (name in names(marker_results_multi)) {
  write.csv(marker_results_multi[[name]], file = paste0("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/csv", name, "_markers.csv"), row.names = FALSE)
}
```

```{r QC visualization functions, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
create_qc_plots <- function(seurat_obj) {
  # RNA QC metrics
  p1 <- ggplot(seurat_obj@meta.data, aes(x = nCount_RNA, y = nFeature_RNA, color = percent_mt_rna)) +
        geom_point(size = 0.5, alpha = 0.5) +
        scale_color_viridis_c() +
        theme_minimal() +
        labs(title = "RNA metrics",
             x = "UMI count",
             y = "Gene count",
             color = "Percent mitochondrial")

  p2 <- ggplot(seurat_obj@meta.data, aes(x = orig.ident, y = nCount_RNA)) +
        geom_violin(aes(fill = orig.ident), show.legend = FALSE) +
        geom_jitter(size = 0.1, alpha = 0.1) +
        theme_minimal() +
        labs(title = "RNA count distribution",
             x = "Sample",
             y = "UMI count")

  p3 <- ggplot(seurat_obj@meta.data, aes(x = orig.ident, y = percent_mt_rna)) +
        geom_violin(aes(fill = orig.ident), show.legend = FALSE) +
        geom_jitter(size = 0.1, alpha = 0.1) +
        theme_minimal() +
        labs(title = "Mitochondrial percentage",
            x = "Sample",
            y = "Percent mitochondrial")

  # ATAC QC metrics
  p4 <-ggplot(seurat_obj@meta.data, aes(x = nCount_ATAC, y = nFeature_ATAC, color = TSS.enrichment)) +
       geom_point(size = 0.5, alpha = 0.5) +
       scale_color_viridis_c() +
       theme_minimal() +
       labs(title = "ATAC metrics",
            x = "ATAC count",
            y = "Peak count",
           color = "TSS enrichment")

  p5 <-ggplot(seurat_obj@meta.data, aes(x = orig.ident, y = nCount_ATAC)) +
       geom_violin(aes(fill = orig.ident), show.legend = FALSE) +
       geom_jitter(size = 0.1, alpha = 0.1) +
       theme_minimal() +
       labs(title = "ATAC count distribution",
             x = "Sample",
             y = "ATAC count")

  p6 <-ggplot(seurat_obj@meta.data, aes(x = orig.ident, y = TSS.enrichment)) +
       geom_violin(aes(fill = orig.ident), show.legend = FALSE) +
       geom_jitter(size = 0.1, alpha = 0.1) +
       theme_minimal() +
       labs(title = "TSS enrichment",
            x = "Sample",
            y = "TSS enrichment score")

  # Combine plots
  combined_plot <- (p1 + p2 + p3) / (p4 + p5 + p6) +
                    plot_layout(guides = 'collect') & theme(legend.position = 'bottom')

  return(combined_plot)
}

plot_qc_distribution <-function(seurat_obj, metric, threshold_low = NA, threshold_high = NA) {
    p <- ggplot(seurat_obj@meta.data, aes(x = .data[[metric]])) +
         geom_histogram(bins = 100, fill = "blue", alpha = 0.7) +
         theme_minimal() +
         labs(title = paste(metric, "distribution"),
              x = metric,
              y = "Count")

    if (!is.na(threshold_low)) {
      p <- p + geom_vline(xintercept = threshold_low, color = "red", linetype = "dashed")
    }

    if (!is.na(threshold_high)) {
      p <- p + geom_vline(xintercept = threshold_high, color = "red", linetype = "dashed")
    }

    return(p)
  }
```

```{r QC parameters set, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
qc_metrics <- c( "nCount_RNA", "nFeature_RNA", "percent_mt_rna", "nCount_ATAC", "nFeature_ATAC", "TSS.enrichment")
qc_thresholds <- list(c(500, 20000), c(200, 5000), c(NA, 20), c(1000, 50000), c(500, 20000), c(2, NA))
```

```{r QC table, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
combined_merged <- PercentageFeatureSet(combined_merged, pattern = "^mt-", col.name = "percent_mt_rna", assay = "RNA")

qc_pass <- data.frame(
  RNA_count_pass = sum(combined_merged$nCount_RNA >= 500 & combined_merged$nCount_RNA <= 20000),
  RNA_feature_pass = sum(combined_merged$nFeature_RNA >= 200 & combined_merged$nFeature_RNA <= 5000),
  MT_percent_pass = sum(combined_merged$percent_mt_rna <= 20),
  ATAC_count_pass = sum(combined_merged$nCount_ATAC >= 1000 & combined_merged$nCount_ATAC <= 50000),
  ATAC_feature_pass = sum(combined_merged$nFeature_ATAC >= 500 & combined_merged$nFeature_ATAC <= 20000),
  TSS_enrichment_pass = sum(combined_merged$TSS.enrichment >= 2))

# Calculate percentages
qc_pass_percent <- round(qc_pass / ncol(combined_merged) * 100, 2)
qc_pass_table <- rbind(qc_pass, qc_pass_percent)

# Calculate percentages
qc_pass_percent <- round(qc_pass / ncol(combined_merged) * 100, 2)
qc_pass_table <- rbind(qc_pass, qc_pass_percent)
```

```{r QC summary, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
summary <-
  data.frame(summary(combined_merged@meta.data[, c("nCount_RNA", "nFeature_RNA", "percent_mt_rna", "nCount_ATAC", "nFeature_ATAC", "TSS.enrichment")]))
```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Create QC plots
Idents(combined_merged) <- combined_merged$Cell_type_by_multimodal

qc_plots <- create_qc_plots(combined_merged)

# Create QC metrics plot
qc_dist_plots <- mapply(function(metric, threshold) {
  plot_qc_distribution(combined_merged, metric, threshold[1], threshold[2])
}, qc_metrics, qc_thresholds, SIMPLIFY = FALSE)
qc_dist_combined <- wrap_plots(qc_dist_plots, ncol = 3)

# QC fueature plots
DefaultAssay(combined_merged) <- "SCT"
mt_rna <- FeaturePlot(object = combined_merged,
                      features = "percent_mt_rna",
                      reduction = "Multi_umap",  # Use UMAP or tSNE for dimensionality reduction
                      label = TRUE, # Label clusters
                      cols = c("lightgrey", "blue"), # Adjust colors to highlight high/low values
                      pt.size = 0.2               # Adjust point size for better visibility
                    )

nCount <- FeaturePlot(object = combined_merged,
                      features = "nCount_RNA",
                      reduction = "Multi_umap", # Use UMAP or tSNE for dimensionality reduction
                      label = TRUE, # Label clusters
                      cols = c("lightgrey", "blue"),# Adjust colors to highlight high/low values
                      pt.size = 0.2               # Adjust point size for better visibility
                    )

nFeature <- FeaturePlot(object = combined_merged,
                        features = "nFeature_RNA",
                        reduction = "Multi_umap", # Use UMAP or tSNE for dimensionality reduction
                        label = TRUE, # Label clusters
                        cols = c("lightgrey", "blue"), # Adjust colors to highlight high/low values
                        pt.size = 0.2               # Adjust point size for better visibility
                        )

DefaultAssay(combined_merged) <- "ATAC"

ATAC_QC <- DensityScatter(combined_merged, x = 'nCount_ATAC', y = 'TSS.enrichment', log_x = TRUE, quantiles = TRUE)

qc_feature_combined <- mt_rna / nCount / nFeature

# Create empty lists to store elbow plots for PCA and LSI
pca_results <- list()
lsi_results <- list()

# Generate ElbowPlot for PCA (RNA data)
for (dims in c(10, 20, 30, 40)) {
  # Elbow plot for the first `dims` components
  pca_plot <- ElbowPlot(combined_merged, reduction = "pca", ndims = dims) +
              ggtitle(paste("PCA -", dims, "Dims"))
  pca_results[[paste0("PCA_", dims)]] <- pca_plot
}

# Generate ElbowPlot for LSI (ATAC data)
for (dims in c(10, 20, 30, 40)) {
  # Elbow plot for the first `dims` components
  lsi_plot <- ElbowPlot(combined_merged, reduction = "lsi", ndims = dims) +
              ggtitle(paste("LSI -", dims, "Dims"))
  lsi_results[[paste0("LSI_", dims)]] <- lsi_plot
}

# Combine all PCA and LSI plots into a grid using cowplot
combined_plots <- plot_grid(plotlist = c(pca_results, lsi_results),
                            ncol = 2, # Number of columns in the grid
                            align = "v"  # Align plots vertically within columns
)

```

```{r Save point - QC , echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
write.csv(qc_pass_table, file.path(output_dir_base, "QC", "csv", "qc_pass_table.csv"))
write.csv(summary, file.path(output_dir_base, "QC", "csv", "summary_qc.csv"), row.names = FALSE)
ggsave(qc_plots, filename = file.path(output_dir_base, "QC", "Plots", "qc_plots.png"), width = 18, height = 12, dpi = 300)
ggsave(qc_dist_combined, filename = file.path(output_dir_base, "QC", "Plots", "qc_distribution_plots.png"), width = 18, height = 12, dpi = 300)
ggsave(mt_rna, filename = file.path(output_dir_base, "QC", "Plots", "mt_rna.png"), width = 8, height = 8, dpi = 300)
ggsave(nCount, filename = file.path(output_dir_base, "QC", "Plots", "nCount.png"), width = 8, height = 8, dpi = 300)
ggsave(nFeature, filename = file.path(output_dir_base, "QC", "Plots", "nFeature.png"), width = 8, height = 8, dpi = 300)
ggsave(qc_feature_combined, filename = file.path(output_dir_base, "QC", "Plots", "qc_featureplot.png"), width = 8, height = 24, dpi = 300)
ggsave(ATAC_QC, filename = file.path(output_dir_base, "QC", "Plots", "ATAC_densityscatter.png"), width = 12, height = 12, dpi = 300)
ggsave(combined_plots, filename = file.path(output_dir_base, "QC", "Plots", "PCA_Elobowplot.png"), width = 8, height = 8, dpi = 300)
```

```{r Dim Plots, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Set assay to RNA
DefaultAssay(combined_merged) <-  "SCT"

# Set identity
Idents(combined_merged) <- combined_merged$RNA_integrated_cluster_0.8 # Choose resoltuion
p1_rna <- DimPlot(combined_merged,
                  reduction = "RNA_integrated_umap",
                  group.by = "RNA_integrated_cluster_0.8",
                  label = TRUE,
                  repel = TRUE) +
          ggtitle("RNA UMAP - RNA_integrated_cluster_0.8") +
          NoLegend()

p2_rna <- DimPlot(combined_merged,
                  reduction = "RNA_integrated_umap",
                  group.by = "sample") +
          ggtitle("RNA UMAP - Original Identity")

p3_rna <- DimPlot(combined_merged,
                  reduction = "RNA_integrated_umap",
                  group.by = "RNA_integrated_cluster_0.8",
                  label = TRUE) +
          ggtitle("RNA UMAP - RNA_integrated_cluster_0.8") +
          NoLegend()

p4_rna <-DimPlot(combined_merged,
                 reduction = "RNA_integrated_umap",
                 group.by = "condition") +
         ggtitle("RNA UMAP - Condition")

p5_rna <- DimPlot(combined_merged,
                  reduction = "RNA_integrated_umap",
                  group.by = "timepoint") +
          ggtitle("RNA UMAP - Timepoint")

# Create ATAC UMAP plots
DefaultAssay(combined_merged) <- "ATAC"

Idents(combined_merged) <- combined_merged$ATAC_integrated_cluster_0.8
p1_atac <-DimPlot(combined_merged,
                  reduction = "ATAC_integrated_umap",
                  group.by = "ATAC_integrated_cluster_0.8",
                  label = TRUE,
                  repel = TRUE) +
          ggtitle("ATAC UMAP - ATAC_integrated_cluster_0.8") +
          NoLegend()

p2_atac <- DimPlot(combined_merged,
                   reduction = "ATAC_integrated_umap",
                   group.by = "sample") +
           ggtitle("ATAC UMAP - Original Identity")
p3_atac <- DimPlot(combined_merged,
                   reduction = "ATAC_integrated_umap",
                   group.by = "ATAC_integrated_cluster_0.8",
                   label = TRUE) +
           ggtitle("ATAC UMAP - Seurat Clusters_0.8") +
           NoLegend()

p4_atac <- DimPlot(combined_merged,
                   reduction = "ATAC_integrated_umap",
                   group.by = "condition") +
           ggtitle("ATAC UMAP - Condition")

p5_atac <- DimPlot(combined_merged,
                   reduction = "ATAC_integrated_umap",
                   group.by = "timepoint") +
           ggtitle("ATAC UMAP - Timepoint")

# Multimodal UMAP plots
DefaultAssay(combined_merged) <- "SCT"
Idents(combined_merged) <- combined_merged$Multimodal_cluster_0.8

# Create Multimodal UMAP plots
p1_multi <- DimPlot(combined_merged,
                    reduction = "Multi_umap",
                    group.by = "Multimodal_cluster_0.8",
                    label = TRUE,
                    repel = TRUE) +
            ggtitle("Multi UMAP - Multimodal_cluster_0.8") +
            NoLegend()

p2_multi <- DimPlot(combined_merged,
                    reduction = "Multi_umap",
                    group.by = "sample") +
            ggtitle("Multi UMAP - Original Identity")
p3_multi <-DimPlot(combined_merged,
                   reduction = "Multi_umap",
                   group.by = "Multimodal_cluster_0.8",
                   label = TRUE) +
           ggtitle("Multi UMAP - Seurat Multimodal_cluster_0.8") +
           NoLegend()

p4_multi <- DimPlot(combined_merged,
                    reduction = "Multi_umap",
                    group.by = "condition") +
            ggtitle("Multi UMAP - Condition")

p5_multi <- DimPlot(combined_merged,
                    reduction = "Multi_umap",
                    group.by = "timepoint") +
            ggtitle("Multi UMAP - Timepoint")

# Combine RNA and ATAC plots
combined_celltype <- p1_rna + p1_atac
combined_orig_ident <- p2_rna + p2_atac
combined_clusters <- p3_rna + p3_atac
combined_condition <- p4_rna + p4_atac
combined_timepoint <- p5_rna + p5_atac

# Arrange all plots
Multi_plots <- (p1_multi + p2_multi) / (p3_multi + p4_multi) / (p5_multi)
RNA_plots <- (p1_rna + p2_rna) / (p3_rna + p4_rna) / (p5_rna)
ATAC_plots <- (p1_atac + p2_atac) / (p3_atac + p4_atac) / (p5_atac)
all_plots <- (combined_celltype) /
  (combined_orig_ident) /
  (combined_clusters) /
  (combined_condition) /
  (combined_timepoint) +
  plot_layout(heights = c(1, 1, 1, 1, 1))

# individual plots
conditions <- unique(combined_merged$sample) # condition, timepoint
DefaultAssay(combined_merged) <- "SCT" # "SCT" "ATAC"

# Generate and save UMAP plots for each condition
for (condition in conditions) {
  # Subset the Seurat object for the current condition
  condition_data <- subset(combined_merged, subset = condition == condition)
  Idents(combined_merged) <- combined_merged$Multimodal_cluster_0.8 # "RNA_integrated_cluster_0.8" "ATAC_integrated_cluster_0.8" "Multimodal_cluster_0.8"

  # Create the UMAP plot
  p <- DimPlot(condition_data,
               reduction = "Multi_umap",  # "RNA_integrated_umap" "ATAC_integrated_umap" or "Multi_umap""
               #group.by = "Multimodal_wsnn_res.0.8", # "RNA_integrated_res.0.8" "ATAC_integrated_snn_res.0.8" or "Multimodal_wsnn_res.0.8"
               label = TRUE,
               repel = TRUE) +
       ggtitle(paste("UMAP_Multimodal_", condition)) + # "UMAP_RNA_" "UMAP_ATAC_" "UMAP_Multimodal_"
       NoLegend()

  # Define the output file name
  plot_file_name <- paste0("UMAP_Multimodal_", condition, ".png") # "UMAP_RNA_" "UMAP_ATAC_" "UMAP_Multimodal_"

  # Save the plot
  ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", plot_file_name), plot = p, width = 16, height = 12, dpi = 300)
  print(paste("Saved UMAP plot for", condition))
}

```

```{r linked umap}
rna_umap <-
    Embeddings(combined_merged, reduction = "RNA_integrated_umap") %>%
    as.data.frame() %>%
    rownames_to_column("cell") %>%
    as_tibble() %>%
    mutate(rna_cluster = as.vector(combined_merged$Cell_type_by_multimodal)) %>%
    dplyr::rename(
        UMAP_1 = RNAintegratedumap_1,
        UMAP_2 = RNAintegratedumap_2
    )

atac_umap <-
    Embeddings(combined_merged_org, reduction = "ATAC_integrated_umap") %>%
    as.data.frame() %>%
    rownames_to_column("cell") %>%
    as_tibble() %>%
    dplyr::rename(
        UMAP_1 = ATACintegratedumap_1,
        UMAP_2 = ATACintegratedumap_2
    ) %>%
    full_join(rna_umap %>%
        dplyr::select(cell, rna_cluster))

# Merging the UMAP data
# Shifted UMAP_1 for both by offset_num to separate the datasets

offset_num <- 15

combined_umap <-
    rna_umap %>%
    mutate(
        data_type = "RNAseq",
        UMAP_1 = UMAP_1 - offset_num
    ) %>%
    bind_rows(atac_umap %>%
        mutate(
            data_type = "ATACseq",
            UMAP_1 = UMAP_1 + offset_num
        ))

for (cluster in unique(combined_merged$Cell_type_by_multimodal)) {
  draw_cluster <- cluster
  
  plot <- ggplot(
    combined_umap,
    aes(
        x = UMAP_1,
        y = UMAP_2,
        shape = data_type
    )
) +
    geom_point(aes(color = rna_cluster == draw_cluster),
        alpha = 0.5
    ) +
    scale_color_brewer(
        palette = "Paired",
        name = "Data type"
    ) +
    geom_vline(
        xintercept = 0,
        linetype = "dashed",
        color = "orange"
    ) +
    geom_line(
        data = combined_umap %>%
            dplyr::filter(rna_cluster == draw_cluster),
        aes(
            x = UMAP_1,
            y = UMAP_2,
            group = cell
        ),
        color = "cyan",
        alpha = 0.05
    )
  
  ggsave(filename = paste0(file.path(output_dir_base, "Plots","DimPlots", "Final"), "Linked_DimPlot_", cluster, "_.png"), width = 16, height = 8, dpi = 300)
  # ggsave(filename = paste0(file.path(output_dir_base, "Plots","DimPlots", "Final_50cells"), "Linked_DimPlot_", cluster, "_.png"), width = 16, height = 8, dpi = 300)
}
```

```{r Save point - UMAP plots, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "comprehensive_RNA_ATAC_UMAP_cell_type.png"), combined_celltype, width = 20, height = 10, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "comprehensive_RNA_ATAC_UMAP_orig.ident.png"), combined_orig_ident, width = 20, height = 10, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "comprehensive_RNA_ATAC_UMAP_clusters.png"), combined_clusters, width = 20, height = 10, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "comprehensive_RNA_ATAC_UMAP_condition.png"), combined_condition, width = 20, height = 10, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "comprehensive_RNA_ATAC_UMAP_timepoint.png"), combined_timepoint, width = 20, height = 10, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "comprehensive_RNA_ATAC_UMAP_all.png"), all_plots, width = 20, height = 50, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "comprehensive_RNA_UMAP_all.png"), RNA_plots, width = 20, height = 50, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "comprehensive_ATAC_UMAP_all.png"), ATAC_plots, width = 20, height = 50, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "comprehensive_Multi_UMAP_all_final.png"), Multi_plots, width = 20, height = 50, dpi = 300, limitsize = F)

ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Multi_UMAP_cell_type.png"), p1_multi, width = 12, height = 12, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Multi_UMAP_orig.ident.png"), p2_multi, width = 12, height = 12, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Multi_clusters.png"), p3_multi, width = 12, height = 12, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Multi_condition.png"), p4_multi, width = 12, height = 12, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Multi_UMAP_timepoint.png"), width = 12, height = 12, dpi = 300, limitsize = F)


```

```{r Link prep ATAC and RNA for coverage plot , echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Set the default assay to ATAC
DefaultAssay(combined_merged) <- "ATAC"

# Compute the gene activity matrix
gene.activities <- GeneActivity(combined_merged)

# Add gene activity scores to the Seurat object as a new assay
combined_merged[["ACTIVITY"]] <- CreateAssayObject(counts = gene.activities)

# Normalize the gene activity scores
combined_merged <- NormalizeData(combined_merged, assay = "ACTIVITY")

# Set default assay to ATAC for linking peaks
DefaultAssay(combined_merged) <- "ATAC"

# Set the genome based on your organism
genome <- BSgenome.Mmusculus.UCSC.mm10  # Replace with appropriate genome if not mouse

# Compute DNA sequence information for peaks in the ATAC assay
combined_merged <- RegionStats(object = combined_merged, assay = "ATAC", genome = genome)

# renaming transcript_id column to tx_id
# Access the ATAC assay annotation data
annotation_data <- Annotation(combined_merged[["ATAC"]])

# Rename the column from 'transcript_id' to 'tx_id'
mcols(annotation_data)$tx_id <- mcols(annotation_data)$transcript_id
mcols(annotation_data)$transcript_id <- NULL  # Remove the old column if desired

# Assign the modified annotation back to the ATAC assay
Annotation(combined_merged[["ATAC"]]) <- annotation_data

# clear workspace
rm("genome", "annotation_data", "gene.activities")
```

```{r Save point - link ATAC and RNA, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Save the linked object
saveRDS(combined_merged, file.path(output_dir_base, "RDS_mid", "combined_merged_processed_multimodal_processed_linked.rds"))
```


```{r Cluster annotation - cell typying, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Load Mousebrain.org file
mouseatlas.cut <- readRDS("/igm/home/hxy008/PTZ_ATAC_scRNA_072024/WIP/Jesse_mousebrain_RDS//mouseatlas_cut_processed.rds")

# Set assay
DefaultAssay(combined_merged) <- "SCT"

# Find anchors betwwen object
anchors <- FindTransferAnchors(reference = mouseatlas.cut, query = combined_merged, dims = 1:30, normalization.method = "SCT")

# Predict the identity - cell types
predictions <- TransferData(anchorset = anchors, refdata = mouseatlas.cut$Description, dims = 1:30)

# add metadata
combined_merged <- AddMetaData(object = combined_merged, metadata = predictions)

# Save to object & assign Idents
combined_merged$mouseatlas.predicted <- combined_merged$predicted.id
Idents(combined_merged) <- combined_merged$mouseatlas.predicted

# Visualize
mb <- DimPlot(combined_merged, reduction = "Multi_umap", label = T, repel = T) + NoLegend()

# Save the list of cell types into a variable
long_names <- c("Excitatory neurons, hippocampus CA1", "Granule neuroblasts, dentate gyrus", "Granule neurons, dentate gyrus",
  "Basket and bistratified cells, cortex/hippocampus", "Axo-axonic, cortex/hippocampus", "Excitatory neurons, cerebral cortex",
  "CGE-derived neurogliaform cells, cortex/hippocampus", "Dentate gyrus radial glia-like cells", "Interneuron-selective interneurons, cortex/hippocampus",
  "Oligodendrocytes precursor cells", "Telencephalon astrocytes, protoplasmic", "Excitatory neurons, hippocampus CA3", "Committed oligodendrocytes cells (COP)",
  "Trilaminar cells, hippocampus", "Hippocamposeptal projection, cortex/hippocampus", "Neuronal intermidate progenitor cells", "Ivy and MGE-derived neurogliaform cells, cortex/hippocampus",
  "Microglia", "Mature oligodendrocytes", "Myelin forming oligodendrocytes (MFOL)", "R-LM border Cck interneurons, cortex/hippocampus", "Non-border Cck interneurons, cortex/hippocampus",
  "Telencephalon astrocytes, fibrous", "Inhibitory interneurons, hippocampus", "Sleep-active, long-range projection interneurons, cortex/hippocampus",
  "CGE-derived neurogliaform cells Cxcl14+, cortex/hippocampus", "Microglia, activated", "Vascular leptomeningeal cells", "Ependymal cells",
  "Newly formed oligodendrocytes (NFOL)", "Cajal-Retzius cells, hippocampus", "Perivascular macrophages", "Vascular endothelial cells, capillary",
  "Pericytes", "Perivascular macrophages, activated", "Vascular endothelial cells, venous")

# Create a short names list
short_names <- c(
  "Ex_Neu_CA1", "Gran_NB_DG", "Gran_Neu_DG", "HP_CTX", "HP_CTX", "Ex_Neu_Cortex", "CGE", "DG_Glial",
  "In_HP_CTX", "OPC", "Astrocytes", "Ex_Neu_CA3", "COP", "HP", "HP", "Neu_Progenitor", "MGE", "Microglia", "Mature_Oligo", "MFOL",
  "In_HP_CTX", "In_HPCTX", "Astrocytes", "In_HP", "Int_HP_CTX", "CGE", "Microglia_Act", "Vascular cells", "Ependymal", "NFOL",
  "HP", "Peri_Macro", "Vascular cells", "Pericytes", "Macrophages", "Vascular cells")

# Create a named vector for easy mapping
name_map <- setNames(short_names, long_names)

# Function to shorten names
shorten_names <- function(x) {ifelse(x %in% names(name_map), name_map[x], x)}

# apply short names
combined_merged$mouseatlas.short <- shorten_names(combined_merged$mouseatlas.predicted)

# check umap
Idents(combined_merged) <- "mouseatlas.short"
mouse <- DimPlot(combined_merged, reduction = "Multi_umap", label = T, repel = T) + NoLegend()
```

```{r Save point - annotation, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(combined_merged, file.path(output_dir_base, "RDS_mid", "combined_merged_processed_multimodal_processed_linked_annotated.rds"))
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "mousebrain_annotation_UMAP.png"), mouse, width = 12, height = 12, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "mousebrain_annotation_UMAP.png"), mb, width = 12, height = 12, dpi = 300, limitsize = F)
```

```{r Cluster annotation fianl, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
Idents(combined_merged) <- combined_merged$Multimodal_cluster_0.4
DimPlot(combined_merged, reduction = "Multi_umap", label = T) + NoLegend()

multimodal_cell_type_mapping <- c(
  "1" = "ExcitatoryNeuronsMatureDG", "12" = "ExcitatoryNeuronsMatureDG",
  
  "2" = "ExcitatoryNeuronsImmatureDG", 
  
  "7" = "OPCs",
  
  "20" = "COPMFOL",
  
  "10" = "CGE", 
  
  "22" = "Lamp5positive",
  
  "4" = "MGE",
  
  "17" = "LGE",

  "5" = "Astrocytes", 
  
  "21" = "Microglia",
  
  "9" = "L23ExcitatoryNeurons", "13" = "L23ExcitatoryNeurons",  
  
  "11" = "L45ExcitatoryNeurons",  "15" = "L45ExcitatoryNeurons", "16" = "L45ExcitatoryNeurons",

  "6" = "L56ExcitatoryNeurons", "23" = "L56ExcitatoryNeurons", 
  
  "3" = "ExcitatoryNeuronsCA3", "18" = "ExcitatoryNeuronsCA3", 

  "0" = "ExcitatoryNeuronsCA1", "8" = "ExcitatoryNeuronsCA1", "14" = "ExcitatoryNeuronsCA1", 

  "19" = "NdnfRelnInhibitoryInterneurons")

# Assign the cell types to the metadata based on cluster IDs
combined_merged@meta.data$Cell_type_by_multimodal <- multimodal_cell_type_mapping[as.character(combined_merged$Multimodal_cluster_0.4)]

Idents(combined_merged) <- "Cell_type_by_multimodal"  #"Multimodal_cluster_0.8" "Cell_type_by_multimodal
multi_anno <- DimPlot(combined_merged, reduction = "Multi_umap", label = TRUE, repel = TRUE) + NoLegend()
```

```{r Save point - finalize annotation, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "multimodal_annotated_UMAP.png"), multi_anno, width = 12, height = 12, dpi = 300, limitsize = F)
saveRDS(combined_merged, file.path(output_dir_base, "RDS_mid", "combined_merged_processed_multimodal_processed_linked_annotated.rds"))
```

```{r Gene list for plotting, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
gene_list <- list(Nsg2 = "Nsg2",
                  Aqp4 = "Aqp4",
                  Apoe = "Apoe",
                  P2ry12 = "P2ry12",
                  Prox1 = "Prox1",
                  Bcl11b = "Bcl11b",
                  Grik4 = "Grik4",
                  Neurod2 = "Neurod2",
                  Mbp = "Mbp",
                  Pdgfra = "Pdgfra",
                  Vip = "Vip",
                  Sst = "Sst",
                  Tbr1 = "Tbr1",
                  Satb2 = "Satb2",
                  Cux2 = "Cux2",
                  Rorb = "Rorb",
                  Slc17a7 = "Slc17a7",
                  Gad1 = "Gad1",
                  Vim = "Vim",
                  Ndnf = "Ndnf",
                  Reln = "Reln",
                  Dcn = "Dcn",
                  Dcx = "Dcx",
                  Tle4 = "Tle4",
                  Meis2 = "Meis2",
                  Lamp5 = "Lamp5",
                  Neurod6 = "Neurod6",
                  Meis2 = "Meis2",
                  Zfhx3 = "Zfhx3",
                  Lhx6 = "Lhx6",
                  Tubb2a = "Tubb2a",
                  Meg3 = "Meg3")
                  # Nr2f1 = "Nr2fa",
                  # Nkx2.1 = "Nkx2.1")

genes_to_plot <- c(
  "Aqp4",  # Astrocytes
  "P2ry12",  # Microglia
  "Pdgfra",  # OPCs
  "Mbp",  # COPMFOL (Myelin-associated)
  "Dcn",  # CA1
  "Matn2",  # CA1
  "Grik4",  # CA3
  "Prox1",  # DG in general CA1-
  "Calb1",  # ExcitatoryNeuronsMatureDG
  "Dcx",  # ExcitatoryNeuronsImmatureDG
  "Satb2",  # cortical neuron
  "Cux2",  # L234ExcitatoryNeurons
  "Bcl11b",  # L5ExcitatoryNeurons CA1+
  "Rorb", # L4/5ExcitatoryNeurons
  "Etv1",  # L5ExcitatoryNeurons
  "Tbr1",  # L56ExcitatoryNeurons
  "Foxp2",  # L6
  "Gad2", # inhibitory neurons
  "Vip",  # CGE-derived cells
  "Meis2",  # LGE-derived interneurons
  "Sst",  # MGE-derived interneurons
  "Ndnf",  # NdnfRelnInhibitoryInterneurons
  "Lamp5",  # Lamp5 Positive
  "Col1a1",  # Vascular Cells
  "Vim"     # Marker for progenitor or stem-like cells
)

IEGs_to_plot <-
  c("Jun", "Fos", "Junb", "Fosb", "Egr1", "Homer1", "Snap25", "Nr4a3")
```

```{r FeaturePlot function, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Function to create and save FeaturePlot
create_feature_plot <- function(seurat_obj, gene, filename) {
  plot <- FeaturePlot(seurat_obj, features = gene,
                                  reduction = "Multi_UMAP", # Adjust if you're using a different dimension reduction
                                  pt.size = 0.1,
                                  order = TRUE, # Plot positive cells on top
                                  min.cutoff = "q1", 
                                  # Set minimum color to 1st quartile
                                  max.cutoff = "q99") +
                                  # Set maximum color to 99th percentile
                      scale_color_gradientn(colors = c("gray90", "blue")) +
                      theme_minimal() +
                      theme(legend.position = "right")
  ggsave(plot, filename = paste0("~/PTZ_ATAC_scRNA_072024/WIP/ModuleTest/Plots/FeaturePlots/", "FeaturePlot_", gene, "_multi.png"), width = 8, height = 7, dpi = 300)}

```

```{r Run Featureplot function, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
for (gene in gene_list) {create_feature_plot(combined_merged, gene)}
for (gene in genes_to_plot) {create_feature_plot(combined_merged, gene)}
for (gene in IEGs_to_plot) {create_feature_plot(combined_merged, gene)}
```

```{r Order the coloumn, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
Idents(combined_merged) <- "Cell_type_by_multimodal"
custom_order <- c(
  "Astrocytes", "Microglia", "OPCs", "COPMFOL",
  "ExcitatoryNeuronsCA1", "ExcitatoryNeuronsCA3", "ExcitatoryNeuronsMatureDG","ExcitatoryNeuronsImmatureDG", 
  "L23ExcitatoryNeurons","L45ExcitatoryNeurons", "L56ExcitatoryNeurons",
   "CGE","LGE", "MGE",  "NdnfRelnInhibitoryInterneurons","Lamp5positive")

# order column
combined_merged$Cell_type_by_multimodal <-
  factor(combined_merged$Cell_type_by_multimodal,
         levels = custom_order)
```

```{r Save point - ordered column, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(combined_merged, file.path(output_dir_base, "RDS_mid","combined_merged_processed_multimodal_processed_linked_annotated_ordered.rds"))
```

```{r VlnPLot, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# color set
col_to_use <-  c("blue", "green", "red", "purple", "orange", "cyan", "magenta", "yellow", "brown", "pink", "lightblue", "darkgreen", "darkred", "gold", "darkblue", "gray", "violet")
```

```{r VlnPot function, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
create_vln_plot <- function(seurat_obj, gene, filename) {
  plot <- VlnPlot(seurat_obj, features = gene,
                  group.by = "sample",
                  cols = col_to_use,
                  pt.size = 0.1) +
    theme_minimal() +
    theme(legend.position = "right")
  ggsave(plot, filename = paste0("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Plots/VlnPlots/", "VlnPlot_", gene, "_multi.png"), width = 8, height = 7, dpi = 300)}
```

```{r Run Vlnplot function, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
for (gene in gene_list) {create_vln_plot(combined_merged, gene)}
for (gene in genes_to_plot) {create_vln_plot(combined_merged, gene)}
for (gene in IEGs_to_plot) {create_vln_plot(combined_merged, gene)}
```

```{r Stacked VlnPlots, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Make sure the RNA assay is set as the default
DefaultAssay(combined_merged) <- "SCT"
Idents(combined_merged) <- combined_merged$Cell_type_by_multimodal

# Create VlnPlot
stacked <- Stacked_VlnPlot(seurat_object = combined_merged, features = genes_to_plot, x_lab_rotate = TRUE)
# stacked_IEGs <- Stacked_VlnPlot(seurat_object = combined_merged, features = IEGs_to_plot, x_lab_rotate = TRUE)
```

```{r Save point - stacked VlnPlot, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
ggsave(stacked, filename = file.path(output_dir_base, "Plots", "VlnPlots", "stacked_markers.png"), width = 8, height = 24, dpi = 300)
# ggsave(stacked_IEGs, filename = file.path(output_dir_base, "Plots", "VlnPlots", "stacked_IEGs.png"), width = 8, height = 24, dpi = 300)
```

```{r Heatmap, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Log-normalize the RNA data
combined_merged_heatmap <- NormalizeData(combined_merged, assay = "RNA", verbose = TRUE) 

# Make sure the RNA assay is set as the default
DefaultAssay(combined_merged_heatmap) <- "RNA"
Idents(combined_merged_heatmap) <- combined_merged_heatmap$Cell_type_by_multimodal

# Calculate for heatmap
ClusterAvg_heatmap <- AggregateExpression(combined_merged_heatmap,
                                  return.seurat = T,
                                  group.by = "Cell_type_by_multimodal",
                                  slot = "data")

# Create heatmap
heatmap <- DoHeatmap(object = ClusterAvg_heatmap,
                     features = genes_to_plot,
                     slot = "data",  # Use raw count data
                     assay = "RNA",
                     label = T,
                     size = 3,
                     angle = 45,
                     draw.lines = FALSE) + 
            scale_fill_gradientn(colors = c("white", "orange", "red")) + NoLegend()
```

```{r Save point - heatmap, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
ggsave(heatmap, filename = file.path(output_dir_base, "Plots", "Heatmap" ,"Heatmap.png"),width = 24, height = 12,dpi = 300)
```

```{r Dot plot}
dot_plot <- DotPlot(
  combined_merged,
  features = genes_to_plot,
  cols = c("green", "red"),
  dot.scale = 8) +
  theme(
    axis.text.x = 
      element_text(
        angle = 90, 
        vjust = 0.8, 
        hjust = 1
        ),
    axis.title.x = 
      element_blank(),
    axis.title.y = 
      element_blank(),
    ) +
  coord_flip()



ggsave(dot_plot, filename = file.path(output_dir_base, "Plots", "DotPlot" ,"DotPlot.png"),width = 12, height = 8,dpi = 300)
```

```{r Final umap/feature plot, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
Idents(combined_merged) <- combined_merged$Cell_type_by_multimodal

# RNA UMAP
p1_rna <- DimPlot(combined_merged,
                  reduction = "RNA_integrated_umap",
                  group.by = "Cell_type_by_multimodal",
                  label = TRUE,
                  repel = TRUE) +
          ggtitle("RNA UMAP - Cell_type_by_multimodal") + 
          NoLegend()

p2_rna <- DimPlot(combined_merged, 
                  reduction = "RNA_integrated_umap", 
                  group.by = "sample") +
          ggtitle("RNA UMAP - Original Identity")

p3_rna <- DimPlot(combined_merged,
                  reduction = "RNA_integrated_umap",
                  group.by = "RNA_integrated_cluster_0.4",
                  label = TRUE) +
          ggtitle("RNA UMAP - RNA_integrated_cluster_0.4") + 
          NoLegend()

p4_rna <-DimPlot(combined_merged, 
                 reduction = "RNA_integrated_umap", 
                 group.by = "condition") +
         ggtitle("RNA UMAP - Condition")

p5_rna <- DimPlot(combined_merged, 
                  reduction = "RNA_integrated_umap", 
                  group.by = "timepoint") +
          ggtitle("RNA UMAP - Timepoint")


# ATAC dimplot multimodal
Idents(combined_merged) <- combined_merged$Cell_type_by_multimodal

# Create ATAC UMAP plots
p1_atac <-DimPlot(combined_merged,
                  reduction = "ATAC_integrated_umap",
                  group.by = "Cell_type_by_multimodal",
                  label = TRUE,
                  repel = TRUE) +
          ggtitle("ATAC UMAP - Cell_type_by_multimodal") + 
          NoLegend()

p2_atac <- DimPlot(combined_merged, 
                   reduction = "ATAC_integrated_umap", 
                   group.by = "sample") + 
           ggtitle("ATAC UMAP - Original Identity")

p3_atac <- DimPlot(combined_merged,
                   reduction = "ATAC_integrated_umap",
                   group.by = "ATAC_integrated_cluster_0.4",
                   label = TRUE) +
           ggtitle("ATAC UMAP - ATAC_integrated_cluster_0.4") + 
           NoLegend()

p4_atac <- DimPlot(combined_merged,
                   reduction = "ATAC_integrated_umap", 
                   group.by = "condition") +
           ggtitle("ATAC UMAP - Condition")

p5_atac <- DimPlot(combined_merged, 
                   reduction = "ATAC_integrated_umap", 
                   group.by = "timepoint") +
           ggtitle("ATAC UMAP - Timepoint")


# Multimodal dimplot
Idents(combined_merged) <- combined_merged$Cell_type_by_multimodal

# Create Multimodal UMAP plots
p1_multi <- DimPlot(combined_merged,
                    reduction = "Multi_umap",
                    group.by = "Cell_type_by_multimodal",
                    label = TRUE,
                    repel = TRUE) +
            ggtitle("Multi UMAP - Cell_type_by_multimodal") + 
            NoLegend()

p2_multi <- DimPlot(combined_merged, 
                    reduction = "Multi_umap",
                    group.by = "sample") +
            ggtitle("Multi UMAP - Original Identity")

p3_multi <-DimPlot(combined_merged,
                   reduction = "Multi_umap",
                   group.by = "Multimodal_cluster_0.4",
                   label = TRUE) +
           ggtitle("Multi UMAP - Multimodal_cluster_0.4") + 
           NoLegend()

p4_multi <- DimPlot(combined_merged, 
                    reduction = "Multi_umap", 
                    group.by = "condition") +
            ggtitle("Multi UMAP - Condition")

p5_multi <- DimPlot(combined_merged, 
                    reduction = "Multi_umap", 
                    group.by = "timepoint") +
            ggtitle("Multi UMAP - Timepoint")

# Combine RNA and ATAC plots
combined_celltype <- p1_rna + p1_atac
combined_orig_ident <- p2_rna + p2_atac
combined_clusters <- p3_rna + p3_atac
combined_condition <- p4_rna + p4_atac
combined_timepoint <- p5_rna + p5_atac

# Arrange all plots
Multi_plots <- (p1_multi + p2_multi) / (p3_multi + p4_multi) / (p5_multi)
RNA_plots <- (p1_rna + p2_rna) / (p3_rna + p4_rna) / (p5_rna)
ATAC_plots <- (p1_atac + p2_atac) / (p3_atac + p4_atac) / (p5_atac)
all_plots <- (combined_celltype) /
  (combined_orig_ident) /
  (combined_clusters) /
  (combined_condition) /
  (combined_timepoint) +
  plot_layout(heights = c(1, 1, 1, 1, 1))

```

```{r Save point - final Dimplots, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "comprehensive_RNA_ATAC_UMAP_cell_type.png"), combined_celltype, width = 20, height = 10, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "comprehensive_RNA_ATAC_UMAP_orig.ident.png"), combined_orig_ident, width = 20, height = 10, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "omprehensive_RNA_ATAC_UMAP_clusters.png"), combined_clusters, width = 20, height = 10, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "comprehensive_RNA_ATAC_UMAP_condition.png"), combined_condition, width = 20, height = 10, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "comprehensive_RNA_ATAC_UMAP_timepoint.png"), combined_timepoint, width = 20, height = 10, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "comprehensive_RNA_ATAC_UMAP_all.png"), all_plots, width = 20, height = 50, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "comprehensive_RNA_UMAP_all.png"), RNA_plots, width = 20, height = 50, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "comprehensive_ATAC_UMAP_all.png"), ATAC_plots, width = 20, height = 50, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "comprehensive_Multi_UMAP_all_final.png"), Multi_plots, width = 20, height = 50, dpi = 300, limitsize = F)

ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "Multi_UMAP_cell_type.png"), p1_multi, width = 12, height = 12, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "Multi_UMAP_orig.ident.png"), p2_multi, width = 12, height = 12, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "Multi_clusters.png"), p3_multi, width = 12, height = 12, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "Multi_condition.png"), p4_multi, width = 12, height = 12, dpi = 300, limitsize = F)
ggsave(filename = file.path(output_dir_base, "Plots", "DimPlots", "Final", "Multi_UMAP_timepoint.png"),p5_multi, width = 12, height = 12, dpi = 300, limitsize = F)

```

```{r Final feature plot, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
DefaultAssay(combined_merged) <- "SCT"
Idents(combined_merged) <- combined_merged$Cell_type_by_multimodal

# Create Featureplot
general_genes <- FeaturePlot(object = combined_merged,
                            features = genes_to_plot,
                            reduction = "Multi_umap",
                            label = TRUE,
                            repel = TRUE,
                            label.size = 3,
                            cols = c("lightgrey", "blue"))

more_genes <- FeaturePlot(object = combined_merged,
                          features = c("Slc17a7", "Npy", "Pvalb", "Fezf2", "Cck", "Sox2",  "Rbfox3", "Tubb3", "Map2", "Syn1", "Camk2a", "Gad1", "Gfap", "Aldh1l1", "Sox10", "Cspg4", "Csf1r", "Siglech"),
                          reduction = "Multi_umap",
                          label = TRUE,
                          repel = TRUE,
                          label.size = 3,
                          cols = c("lightgrey", "blue"))

# individual plot function
create_feature_plot <- function(seurat_obj, gene, filename) {
  plot <- FeaturePlot(seurat_obj,
                      features = gene,
                      reduction = "Multi_umap", # Adjust if you're using a different dimension reduction
                      pt.size = 0.1,
                      order = TRUE, # Plot positive cells on top
                      min.cutoff = "q1", # Set minimum color to 1st quartile
                      max.cutoff = "q99"  # Set maximum color to 99th percentile
                      ) +
          scale_color_gradientn(colors = c("gray90", "blue")) +
          theme_minimal() +
          theme(legend.position = "right")
  
  # save plot
  ggsave(plot, filename = file.path(output_dir_base, "Plots", "FeaturePlots", paste0("FeaturePlot_", gene, "_multi.png")),
    width = 8, height = 7, dpi = 300)
}
```

```{r Run function/Save point - final feature plot, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Create FeaturePlots for all genes
for (gene in genes_to_plot) {create_feature_plot(combined_merged, gene)}

ggsave(more_genes, filename = file.path(output_dir_base, "Plots", "FeaturePlots", "FeaturePlot_more_genes.png"), width = 24, height = 24, dpi = 300)
ggsave(general_genes, filename = file.path(output_dir_base, "Plots", "FeaturePlots", "FeaturePlot_markers.png"), width = 24, height = 28, dpi = 300)
```

```{r Filter clusters based on cell count, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# cell counts
cell_counts <- table(combined_merged$Cell_type_by_multimodal, combined_merged$sample)
cell_counts_df <- as.data.frame.matrix(cell_counts)
numeric_columns <- sapply(cell_counts_df, is.numeric)
cell_counts_df$Total <- rowSums(cell_counts_df[, numeric_columns], na.rm = TRUE)
cell_counts_df <- rownames_to_column(cell_counts_df, var = "Cell_Type")
cell_counts_df <- cell_counts_df[, c("Cell_Type", "PTZ_1hr", "PTZ_24hr", "SAL_1hr", "SAL_24hr", "Total")]

# orginal
clusters_to_keep <-  cell_counts_df$Cell_Type[apply(cell_counts_df[,-1], 1, function(x) min(x) >= 0)]

# Identify clusters with >= 100 cells
clusters_to_keep_100 <- cell_counts_df$Cell_Type[apply(cell_counts_df[,-1], 1, function(x) min(x) >= 100)]

# Filter the Seurat object
combined_merged_filtered_100 <- subset(combined_merged, subset = Cell_type_by_multimodal %in% clusters_to_keep_100)

# Identify clusters with >= 50 cells
clusters_to_keep_50 <- cell_counts_df$Cell_Type[apply(cell_counts_df[,-1], 1, function(x) min(x) >= 50)]

# Filter the Seurat object
combined_merged_filtered_50 <- subset(combined_merged, subset = Cell_type_by_multimodal %in% clusters_to_keep_50)
combined_merged_filtered_100 <- subset(combined_merged, subset = Cell_type_by_multimodal %in% clusters_to_keep_100)
```

```{r Save point - subset, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(combined_merged_filtered_50, file.path(output_dir_base, "RDS_mid", "combined_merged_final_50cells.rds"))
saveRDS(combined_merged_filtered_100, file.path(output_dir_base, "RDS_mid", "combined_merged_final_100cells.rds"))
write.csv(cell_counts_df, file.path(output_dir_base, "csv", "cell_counts_summary_all.csv"), row.names = TRUE)
```

```{r DEG parameter, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# output_dir_base <-"~/PTZ_ATAC_scRNA_072024/WIP/0428_run"
# combined_merged <- readRDS(file.path(output_dir_base, "RDS_mid", "combined_merged_atac_work.rds"))
# combiend_merged <- combined_merged_filtered_50

# Set the default assay to RNA
DefaultAssay(combined_merged) <- "RNA"
combined_merged <- NormalizeData(combined_merged, normalization.method = "LogNormalize", scale.factor = 1e4)

# Define lists of cell types and comparisons
cell_types <- unique(combined_merged$Cell_type_by_multimodal)
comparisons_to_analyze <- list(
  "PTZvsSAL_24hr" = list(name = "PTZvsSAL_24hr", group1 = "PTZ_24hr", group2 = "SAL_24hr"),
  "PTZvsSAL_1hr" = list(name = "PTZvsSAL_1hr", group1 = "PTZ_1hr", group2 = "SAL_1hr"),
  "24hrvs1hr_PTZ" = list(name = "24hrvs1hr_PTZ", group1 = "PTZ_24hr", group2 = "PTZ_1hr"),
  "24hrvs1hr_SAL" = list(name = "24hrvs1hr_SAL", group1 = "SAL_24hr", group2 = "SAL_1hr")
)

```

```{r DEG loop, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
output_dir_base <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run_/"
dir.create(output_dir_base)

# Main analysis loop with error handling
for (cell_type in cell_types) {
  for (comp in comparisons_to_analyze) {
      # Subset data
      # subsetting cell type in each condition
      cell_type_data <- subset(combined_merged,
                               subset = Cell_type_by_multimodal == cell_type & sample %in% c(comp$group1, comp$group2))

      # Set identities
      Idents(cell_type_data) <- "sample"
      
      # Get cell counts
      cell_count_group1 <- sum(Idents(cell_type_data) == comp$group1)
      cell_count_group2 <- sum(Idents(cell_type_data) == comp$group2)
      
      message(sprintf("Cell counts - %s: %d, %s: %d", # %s for string, %d for integer
                     comp$group1, cell_count_group1,
                     comp$group2, cell_count_group2))
      
      # Check minimum cell threshold (e.g., 3 cells per group)
      if (cell_count_group1 >= 3 && cell_count_group2 >= 3) {
        # Perform DE analysis
        de_results <- FindMarkers(
          object = cell_type_data,
          assay = "SCT", # RNA for MAST, SCT for wilcox
          slot = "data",
          ident.1 = comp$group1,
          ident.2 = comp$group2,
          min.pct = 0.25,
          logfc.threshold = 0.0,
          # return.thresh = 1.01, # depreciated
          test.use = "wilcox"
        )
        
        # Add metadata
        de_results$gene <- rownames(de_results)
        de_results$cell_type <- cell_type
        de_results$comparison <- comp$name
        
        # Save results
        csv_filename <- sprintf("DE_results_%s_%s.csv", cell_type, comp$name)
        write.csv(
          de_results,
          file = file.path(output_dir_base, "Filtered_50_cells", "DE_gene", csv_filename),
          row.names = FALSE
        )
        
    }
  }
}
```

```{r VolcanoPlot, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# file read
csv_files <- list.files(file.path(output_dir_base,  "Filtered_50_cells", "DE_gene"), pattern = "DE_results_.+\\.csv$", full.names = TRUE)

# loop
for (csv_file in csv_files) {
  # Extract cell type and comparison name from file name
  file_name <- basename(csv_file)
  parts <- strsplit(gsub("DE_results_|.csv", "", file_name), "_")[[1]]
  cell_type <- parts[1]
  comparison_name <- paste(parts[-1], collapse = "_")
  
  # Replace colons with underscores in comparison name
  safe_comparison_name <- gsub("[:]", "_", comparison_name)
  print(paste("Creating volcano plot for", cell_type, "-", comparison_name))
  
  # Read CSV file
  de_results <- read.csv(csv_file)
  
  if (nrow(de_results) == 0) {
    next
  } else {
    # Create volcano plot
    volcano_plot <- EnhancedVolcano(de_results,
                                    lab = de_results$gene,
                                    x = 'avg_log2FC',
                                    y = 'p_val_adj',
                                    title = paste('Volcano plot -', cell_type),
                                    subtitle = safe_comparison_name,
                                    pCutoff = 0.05,
                                    FCcutoff = 0.2,
                                    pointSize = 1.0,
                                    labSize = 3.0
                                  )
    
    # Save volcano plot with safe filename
    plot_file_name <- paste0("Volcano_plot_", cell_type, "_", safe_comparison_name, ".png")
    ggsave(file.path(output_dir_base, "Filtered_50_cells", "Plots","VolcanoPlots", plot_file_name), volcano_plot, width = 12, height = 10)
    print(paste("Saved volcano plot:", plot_file_name))
  }}
```

```{r Sig DEG, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# sig calculation function
get_significant_genes <- function(de_results, p_cutoff = 0.05, fc_cutoff = 0.2) {
                          significant_genes <- de_results %>%
                            mutate(Regulation = case_when(
                              avg_log2FC > 0 ~ "Up",
                              avg_log2FC < 0 ~ "Down",
                              TRUE ~ "NoChange")) %>%
                            dplyr::filter(p_val_adj < p_cutoff & abs(avg_log2FC) >= fc_cutoff) %>%
                            arrange(p_val_adj)
                          return(significant_genes)
                        }

# Get list of CSV files in the input directory
output_dir_base <-  "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/"
csv_files <- list.files(file.path(output_dir_base,"Filtered_50_cells", "DE_gene"), pattern = "DE_results_.+\\.csv$", full.names = TRUE)

# Initialize a list to store summaries
summary_list <- list()

# loop for sig gene and save
for (csv_file in csv_files) {
  # Extract cell type and comparison name from file name
  file_name <- basename(csv_file)
  parts <- strsplit(gsub("DE_results_|.csv", "", file_name), "_")[[1]]
  cell_type <- parts[1]
  comparison_name <- paste(parts[-1], collapse = "_")
  
  # Replace colons with underscores in comparison name
  safe_comparison_name <- gsub("[:]", "_", comparison_name)
  print(paste("Processing", cell_type, "-", comparison_name))
  
  # Read CSV file
  de_results <- read.csv(csv_file)
  
  # Get significant genes
  significant_genes <- get_significant_genes(de_results)
  
  # Save significant genes with safe filename
  sig_genes_filename <- paste0("Significant_genes_", cell_type, "_", safe_comparison_name, ".csv")
  
  write.csv(significant_genes, file = file.path(sig_dir,sig_genes_filename), row.names = FALSE)
  print(paste("Saved significant genes:", sig_genes_filename))
  
}
```

```{r DEG summary, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
create_deg_summary <- function(deg_dir) {
  # Get all DEG files
  deg_files <- list.files(deg_dir, pattern = "DE_results_.+\\.csv$", full.names = TRUE)
  
  # Initialize list to store summaries
  deg_summaries <- list()

  for (file in deg_files) {
    
    # Extract metadata from filename
    file_name <- basename(file)
    parts <- strsplit(gsub("DE_results_|.csv", "", file_name), "_")[[1]]
    cell_type <- parts[1]
    comparison_name <- paste(parts[-1], collapse = "_")
    
    # Read DEG results
    deg_data <- read.csv(file)
    
    # Calculate summary statistics
    total_genes <- nrow(deg_data)
    up_regulated <- sum(deg_data$avg_log2FC > 0.2 & deg_data$p_val_adj < 0.05)
    down_regulated <- sum(deg_data$avg_log2FC < -0.2 & deg_data$p_val_adj < 0.05)
    significant_genes <- sum(deg_data$p_val_adj < 0.05)
    
    # Compute top genes
    top_up_genes <- deg_data$gene[deg_data$avg_log2FC > 0.2 & deg_data$p_val_adj < 0.05]
    top_down_genes <- deg_data$gene[deg_data$avg_log2FC < -0.2 & deg_data$p_val_adj < 0.05]
    top_sig_genes <- deg_data$gene[deg_data$p_val_adj < 0.05]
    
    # Get significant up and down genes separately
    sig_up_genes <- deg_data$gene[deg_data$avg_log2FC > 0 & deg_data$p_val_adj < 0.05]
    sig_down_genes <- deg_data$gene[deg_data$avg_log2FC < 0 & deg_data$p_val_adj < 0.05]

    # Create summary row
    summary_row <- data.frame(
      Cell_Type = cell_type,
      Comparison = comparison_name,
      Total_DEGs = total_genes,
      Upregulated = up_regulated,
      Downregulated = down_regulated,
      Significant_Genes = significant_genes,
      Sig_Upregulated = length(sig_up_genes),
      Sig_Downregulated = length(sig_down_genes),
      Top_Up_Genes = paste(head(top_up_genes, 10), collapse = ", "),
      Top_Down_Genes = paste(head(top_down_genes, 10), collapse = ", "),
      Top_Significant_Genes = paste(head(top_sig_genes, 10), collapse = ", "),
      Sig_Up_Genes_List = paste(head(sig_up_genes, 10), collapse = ", "),
      Sig_Down_Genes_List = paste(head(sig_down_genes, 10), collapse = ", ")
    )
    
    deg_summaries[[length(deg_summaries) + 1]] <- summary_row
  }
  
  # Combine all summaries into a single dataframe
  deg_summary_df <- do.call(rbind, deg_summaries)
  
  return(deg_summary_df)
}

# Generate summary
complete_summary <- create_deg_summary(deg_dir = file.path(output_dir_base,"Filtered_50_cells", "DE_gene"))

# Save summary
write.csv(complete_summary, file.path(output_dir_base, "Filtered_50_cells", "Summary", "DEG_Complete_Analysis_Summary.csv"), row.names = FALSE)
```

```{r DEG comparison, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Read the summary files
# complete_summary <-read.csv("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Summary/DEG_Complete_Analysis_Summary.csv")

# rename for consistency.
complete_summary <- complete_summary %>%
  dplyr::rename(Cell_Type = Cell_Type, 
         Comparison = Comparison, 
         Total_DEGs = Total_DEGs, 
         Upregulated = Upregulated, 
         Downregulated = Downregulated, 
         Significant_Genes = Significant_Genes)

# Pivot `complete_summary` for stacked bar chart
deg_long <- complete_summary %>% 
  pivot_longer(cols = c(Upregulated, Downregulated), names_to = "Regulation", values_to = "Count")

# 1. Stacked Bar Chart of Up/Down Regulated Genes by Cell Type and Comparison
p1_stacked <- ggplot(deg_long, aes(x = reorder(Cell_Type, -Count), y = Count, fill = Regulation)) +
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ Comparison, scales = "free_y") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = margin(10, 20, 40, 20)) +
  labs(
    title = "Up/Down Regulated Genes by Cell Type and Comparison",
    subtitle = "Significant genes (p < 0.05, |log2FC| > 0.)",
    y = "Number of Genes"
  ) +
  scale_fill_manual(values = c("Upregulated" = "#66c2a5", "Downregulated" = "#fc8d62"), name = "Regulation") +
  geom_text(aes(label = Count), position = position_stack(vjust = 0.5), size = 3)

# 2. Side-by-Side Bar Chart for Up/Down Regulated Genes
p1 <- ggplot(deg_long, aes(x = reorder(Cell_Type, -Count), y = Count, fill = Regulation)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  facet_wrap(~ Comparison, scales = "free_y") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 20, 40, 20),
    panel.grid.major.x = element_blank()
  ) +
  labs(
    title = "Up/Down Regulated Genes by Cell Type and Comparison",
    subtitle = "Significant genes (p < 0.05, |log2FC| > 0.)",
    y = "Number of Genes"
  ) +
  scale_fill_manual(values = c("Upregulated" = "#66c2a5", "Downregulated" = "#fc8d62"), name = "Regulation") +
  geom_text(aes(label = Count), position = position_dodge(width = 0.8), vjust = -0.5, size = 3)

ggsave(file.path("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Summary/Sig_UpDown_Distribution_stacked.png"), p1_stacked, width = 18, height = 12)
ggsave(file.path("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Summary/Sig_UpDown_Distribution.png"), p1, width = 16, height = 12)

# 3. Comparison of Total DEGs vs Significant Genes
long_summary <- complete_summary %>% 
  pivot_longer(cols = c(Total_DEGs, Significant_Genes), names_to = "Gene_Category", values_to = "Count") %>%
  mutate(Gene_Category = recode(Gene_Category, 
                                "Total_DEGs" = "Total Genes", 
                                "Significant_Genes" = "DEGs"))

p2 <- ggplot(long_summary, aes(x = reorder(Cell_Type, -Count), y = Count, fill = Gene_Category)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
  facet_wrap(~ Comparison, scales = "free_y") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 20, 40, 20),
    panel.grid.major.x = element_blank()
  ) +
  labs(
    title = "Comparison of Total Genes vs DEGs",
    subtitle = "Significant genes (p < 0.05)",
    y = "Number of Genes"
  ) +
  scale_fill_manual(values = c("Total Genes" = "#66c2a5", "DEGs" = "#fc8d62"), name = "Gene_Category") +
  geom_text(aes(label = Count), position = position_dodge(width = 0.8), vjust = -0.5, size = 3.5)

p2_stacked <- ggplot(long_summary, aes(x = reorder(Cell_Type, -Count), y = Count, fill = Gene_Category)) +
  geom_bar(stat = "identity", position = "stack") +  # Stacked bars
  facet_wrap(~ Comparison, scales = "free_y") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.margin = margin(10, 20, 40, 20)
  ) +
  labs(
    title = "Comparison of Total Genes vs DEGs",
    subtitle = "Significant genes (p < 0.05)",
    y = "Number of Genes"
  ) +
  scale_fill_manual(values = c("Total Genes" = "#66c2a5", "DEGs" = "#fc8d62"), name = "Gene Category") +
  geom_text(aes(label = Count), position = position_stack(vjust = 0.5), size = 3)


ggsave(file.path("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Summary/DEG_vs_SigGenes.png"), p2, width = 16, height = 12)
ggsave(file.path("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Summary/DEG_vs_SigGenes_stacked.png"), p2_stacked, width = 16, height = 12)


# 4. Create Individual Plots for Each Comparison
for (comp in unique(deg_long$Comparison)) {
  p4 <- deg_long %>% filter(Comparison == comp) %>% 
    ggplot(aes(x = reorder(Cell_Type, -Count), y = Count, fill = Regulation)) +
    geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid.major.x = element_blank(),
      plot.margin = margin(10, 20, 40, 20),
      axis.title = element_text(size = 12),
      legend.title = element_text(size = 11),
      legend.text = element_text(size = 10)
    ) +
    labs(
      title = paste("Sigs in", comp),
      subtitle = "",
      y = "Number of Genes",
      x = "Cell Type"
    ) +
    scale_fill_manual(values = c("Downregulated" = "#2166AC", "Upregulated" = "#B2182B")) +
    geom_text(aes(label = Count), position = position_dodge(width = 0.8), vjust = -0.5, size = 3.5)
  
  ggsave(file.path(paste0("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Summary/Sig_UpDown_", comp, "_from_summary.png")), p4, width = 10, height = 6, dpi = 300)
}

for (comp in unique(long_summary$Comparison)) {
  p5 <- long_summary %>% filter(Comparison == comp) %>% 
    ggplot(aes(x = reorder(Cell_Type, -Count), y = Count, fill = Gene_Category)) +
    geom_bar(stat = "identity", position = position_dodge(width = 0.8), width = 0.7) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid.major.x = element_blank(),
      plot.margin = margin(10, 20, 40, 20),
      axis.title = element_text(size = 12),
      legend.title = element_text(size = 11),
      legend.text = element_text(size = 10)
    ) +
    labs(
      title = paste("DEG vs Sig in", comp),
      subtitle = "",
      y = "Number of Genes",
      x = "Cell Type"
    ) +
    scale_fill_manual(values = c("Total Genes" = "#2166AC", "DEGs" = "#B2182B")) +
    geom_text(aes(label = Count), position = position_dodge(width = 0.8), vjust = -0.5, size = 3.5)
  
  ggsave(file.path(paste0("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Summary/DEG_vs_Sig_", comp, "_from_summary.png")), p5, width = 10, height = 6, dpi = 300)
}

# stacked individual
for (comp in unique(deg_long$Comparison)) {
  p4_stacked <- deg_long %>% filter(Comparison == comp) %>% 
    ggplot(aes(x = reorder(Cell_Type, -Count), y = Count, fill = Regulation)) +
    geom_bar(stat = "identity", position = "stack") +  # Stacked bars
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid.major.x = element_blank(),
      plot.margin = margin(10, 20, 40, 20),
      axis.title = element_text(size = 12),
      legend.title = element_text(size = 11),
      legend.text = element_text(size = 10)
    ) +
    labs(
      title = paste("Sigs in", comp),
      subtitle = "",
      y = "Number of Genes",
      x = "Cell Type"
    ) +
    scale_fill_manual(values = c("Downregulated" = "#2166AC", "Upregulated" = "#B2182B")) +
    geom_text(aes(label = Count), position = position_stack(vjust = 0.5), size = 3.5)

  ggsave(file.path(paste0("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Summary/Sig_UpDown_", comp, "_stacked.png")), 
         p4_stacked, width = 10, height = 6, dpi = 300)
}

for (comp in unique(long_summary$Comparison)) {
  p5_stacked <- long_summary %>% filter(Comparison == comp) %>% 
    ggplot(aes(x = reorder(Cell_Type, -Count), y = Count, fill = Gene_Category)) +
    geom_bar(stat = "identity", position = "stack") +  # Stacked bars
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid.major.x = element_blank(),
      plot.margin = margin(10, 20, 40, 20),
      axis.title = element_text(size = 12),
      legend.title = element_text(size = 11),
      legend.text = element_text(size = 10)
    ) +
    labs(
      title = paste("DEG vs Sig in", comp),
      subtitle = "",
      y = "Number of Genes",
      x = "Cell Type"
    ) +
    scale_fill_manual(values = c("Total Genes" = "#2166AC", "DEGs" = "#B2182B")) +
    geom_text(aes(label = Count), position = position_stack(vjust = 0.5), size = 3.5)

  ggsave(file.path(paste0("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Summary/DEG_vs_Sig_", comp, "_stacked.png")), 
         p5_stacked, width = 10, height = 6, dpi = 300)
}
```

```{r DEG scatterplot for correlation, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Read the summary files
complete_summary <- read.csv(file.path(output_dir_base, "Filtered_50_cells", "Summary", "DEG_Complete_Analysis_Summary.csv"))

# Loop through each comparison and create a scatter plot
comparisons <- unique(complete_summary$Comparison)

# Define a function to calculate Pearson correlation and linear regression for each comparison
calculate_correlation <- function(data) {
  correlation <- cor.test(data$Total_DEGs, data$Significant_Genes, method = "pearson")
  
  # Perform linear regression
  linear_model <- lm(Significant_Genes ~ Total_DEGs, data = data)
  summary_lm <- summary(linear_model)
  
  # Extract correlation coefficient and p-value
  correlation_coefficient <- correlation$estimate
  p_value <- correlation$p.value
  lm_p_value <-
    summary_lm$coefficients[2, 4]  # p-value of the slope
  
  return(list(correlation_coefficient = correlation_coefficient, 
              pearson_p_value = p_value,
              lm_p_value = lm_p_value))
}

# Initialize a list to store results
correlation_results <- list()

# Loop through each comparison and calculate correlation
comparisons <- unique(complete_summary$Comparison)

for (comp in comparisons) {
  # Filter data for the current comparison
  comp_data <- complete_summary %>% filter(Comparison == comp)
  # Calculate correlation and linear regression for this comparison
  result <- calculate_correlation(comp_data)
  # Store results in a data frame for easy viewing
  correlation_results[[comp]] <- data.frame(Comparison = comp, 
                                            Pearson_Correlation = result$correlation_coefficient, 
                                            Pearson_p_value = result$pearson_p_value, 
                                            LM_p_value = result$lm_p_value)
  
  # Create the scatter plot for the current comparison with updated style
  scatter_plot <- ggplot(comp_data, aes(x = Total_DEGs, y = Significant_Genes, color = Cell_Type)) +
    geom_point(size = 3, alpha = 0.7) +
    geom_text_repel(aes(label = Cell_Type), size = 3, max.overlaps = 10) +
    geom_smooth(method = "lm", color = "red", se = FALSE) +
    labs(title = paste("Total Genes vs DEGs -", comp), 
         subtitle = paste0("Pearson Correlation: ", round(result$correlation_coefficient, 2), ", p-value: ", signif(result$pearson_p_value, 3)), 
         x = "Total Number of Genes", 
         y = "Number of DEGs") +
    theme_minimal() +
    theme(legend.position = "none", 
          plot.title = element_text(hjust = 0.5, size = 14, face = "bold"), 
          plot.subtitle = element_text(hjust = 0.5, size = 12), 
          axis.text = element_text(size = 12), 
          axis.title = element_text(size = 14))
  
  # Save the plot
  plot_file_name <- paste0("Scatter_Total_vs_Significant_DEGs_", gsub("[:]", "_", comp), ".png")
  ggsave(filename = file.path(output_dir_base, "Filtered_50_cells", "Plots", "ScatterPlots", plot_file_name), plot = scatter_plot, width = 10, height = 8, dpi = 300)
}

# Combine results into a single data frame
correlation_results_df <- do.call(rbind, correlation_results)

# Save the results as a CSV file
write.csv(correlation_results_df, file = file.path(output_dir_base, "Filtered_50_cells", "Summary", "Correlation_Results.csv"), row.names = FALSE)
```

```{r Venndiagram functions, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Classic VennDiagram Creation
 
# Color Palette Management
# This function provides a consistent color scheme across all visualizations
# The colors are chosen to be visually distinct and colorblind-friendly
get_venn_colors <- function(n) {
  # Define a carefully selected color palette
  colors <- c("#E64B35",  # Red-orange: good for primary comparisons
              "#4DBBD5",  # Blue: provides good contrast with red-orange
              "#00A087",  # Teal: maintains visibility in overlap regions
              "#3C5488",  # Navy: works well with other colors
              "#F39B7F",  # Light orange: good for additional sets
              "#8491B4",  # Light blue: maintains readability
              "#91D1C2",  # Light teal: useful for complex overlaps
              "#DC0000"   # Bright red: high visibility when needed
            )
  # Return only the number of colors needed
  colors[1:n]
}

# This function creates traditional Venn diagrams with support for 2-4 sets
create_venn_diagram <- function(gene_sets, cell_type, output_dir) {
  tryCatch({
    message(sprintf("Creating VennDiagram plot for %s...", cell_type))
    
    # Get the names of our comparison sets
    category_names <- names(gene_sets)
    
    # Create different diagram types based on number of sets
    # Each type requires specific customization for optimal visibility
    if (length(gene_sets) == 2) {
      # Two-set comparison: Simple side-by-side circles
      venn_plot <- venn.diagram(x = gene_sets,
                                category.names = category_names,
                                filename = NULL,
                                output = FALSE,
                                col = "black",
                                fill = get_venn_colors(2),
                                alpha = 0.5,           # Semi-transparent for overlap visibility
                                label.col = c("black", "black", "black"),
                                cex = 2,              # Text size for counts
                                fontfamily = "sans",   # Clean, modern font
                                cat.cex = 1.5,        # Category label size
                                cat.col = "black",
                                cat.fontfamily = "sans",
                                margin = 0.1,
                                main = paste("VennDiagram -", cell_type),
                                main.cex = 2)
    } else if (length(gene_sets) == 3) {
      # Three-set comparison: Classic three-circle Venn
      venn_plot <- venn.diagram(x = gene_sets,
                                category.names = category_names,
                                filename = NULL,
                                output = FALSE,
                                col = "black",
                                fill = get_venn_colors(3),
                                alpha = 0.5,
                                label.col = rep("black", 7),  # Labels for all regions
                                cex = 2,
                                fontfamily = "sans",
                                cat.cex = 1.5,
                                cat.col = "black",
                                cat.fontfamily = "sans",
                                margin = 0.1,
                                main = paste("VennDiagram -", cell_type),
                                main.cex = 2)
    } else if (length(gene_sets) == 4) {
      # Four-set comparison: More complex with additional overlaps
      venn_plot <- venn.diagram(x = gene_sets,
                                category.names = category_names,
                                filename = NULL,
                                output = FALSE,
                                col = "black",
                                fill = get_venn_colors(4),
                                alpha = 0.5,
                                label.col = rep("black", 15),  # More regions need labels
                                cex = 1.5,            # Slightly smaller text for space
                                fontfamily = "sans",
                                cat.cex = 1.2,
                                cat.col = "black",
                                cat.fontfamily = "sans",
                                margin = 0.1,
                                main = paste("VennDiagram -", cell_type),
                                main.cex = 2)
    }
    
    # Save the plot with high resolution
    png(file.path(output_dir_base, "Filtered_50_cells", "Overlap_analysis", "VennDiagram", paste0("VennDiagram_", cell_type, ".png")),
      width = 3000, height = 3000, res = 300)
    grid.draw(venn_plot)
    dev.off()
    
    return(venn_plot)
  }, error = function(e) {
    message(sprintf("Error creating VennDiagram plot for %s: %s", 
                    cell_type, e$message))
    return(NULL)
  })
}

# This function creates area-proportional Euler diagrams that accurately represent
# the relationships between different gene sets. Unlike Venn diagrams, Euler diagrams
# can show exact proportional relationships between sets.
create_euler_plot <- function(gene_sets, cell_type, output_dir) {
  tryCatch({
    message(sprintf("Creating Euler plot for %s...", cell_type))
    
    # First, we need to identify all unique genes across all sets
    # This creates our universe of genes for comparison
    all_genes <- unique(unlist(gene_sets))
    
    # Create a presence/absence matrix for efficient set operations
    # This matrix has rows for each gene and columns for each set
    # A TRUE value indicates the gene is present in that set
    set_matrix <- matrix(FALSE,                          # Initialize all values to FALSE
                  nrow = length(all_genes),       # One row per unique gene
                  ncol = length(gene_sets),       # One column per gene set
                  dimnames = list(all_genes,                  # Row names are gene names
                             names(gene_sets)            # Column names are set names
                  ))
    # Fill the matrix with presence/absence information
    # We iterate through each set and mark which genes are present
    for(set_name in names(gene_sets)) {
      set_matrix[gene_sets[[set_name]], set_name] <- TRUE
    }
    
    # Create the Euler diagram using the presence/absence matrix
    # The euler() function calculates the optimal layout that preserves
    # the true proportions of set intersections
    euler_fit <- euler(set_matrix)
    
    # Define a color palette specifically for Euler diagrams
    # These colors are chosen to be visually distinct while maintaining
    # readability when sets overlap
    get_euler_colors <- function(n) {
      colors <- c(
        "#FF9999",  # Light red - good base for overlaps
        "#66B2FF",  # Light blue - contrasts well with red
        "#99FF99",  # Light green - visible in combinations
        "#FFCC99",  # Light orange - works well with other colors
        "#FF99CC",  # Light pink - maintains distinction
        "#99CCFF",  # Pale blue - good for additional sets
        "#FFB366",  # Light brown - provides contrast
        "#FF99FF"   # Light purple - completes the palette
      )
      return(colors[1:min(n, length(colors))])
    }
    
    # Create the actual plot with careful attention to visual clarity
    euler_plot <- plot(euler_fit,
                        quantities = TRUE,     # Show the number of genes in each region
                        fill = get_euler_colors(length(gene_sets)),
                        edges = list(col = "black",     # Black borders for clear set boundaries
                                            lwd = 1           # Thin lines for a clean look
                        ),
                        labels = list(font = 2,         # Bold font for better readability
                                      cex = 0.8        # Slightly smaller text to avoid crowding
                                      ),
                        main = paste("Euler Diagram -", cell_type),
                        mar = c(2, 2, 2, 2)   # Margins for balanced layout
                      )
    
    # Save the plot with high resolution for publication quality
    # The dimensions and resolution are chosen for optimal viewing
    png(file.path(output_dir_base, "Filtered_50_cells", "Overlap_analysis", "Euler", paste0("Euler_", cell_type, ".png")),
      width = 10, height = 10, units = "in", res = 300)
    plot(euler_plot)
    dev.off()
    
    # Return the euler fit object for potential further analysis
    # This object contains detailed information about set relationships
    return(euler_fit)
  }, error = function(e) {
    message(sprintf("Error creating Euler plot for %s: %s", 
                    cell_type, e$message))
    return(NULL)
  })
}

# ggVenn Plot Creation
# This function creates modern, customizable Venn diagrams using ggplot2
create_ggvenn_plot <- function(gene_sets, cell_type, output_dir) {
  tryCatch({
    message(sprintf("Creating ggVenn plot for %s...", cell_type))
    
    # Create the Venn diagram with careful attention to readability
    venn_plot <- ggvenn(gene_sets, fill_color = get_venn_colors(length(gene_sets)),
                        stroke_size = 0.5,      # Thin lines for clean appearance
                        set_name_size = 4,      # Readable but not overwhelming text
                        show_percentage = FALSE  # Focus on actual gene counts
                        ) +
                # Add a clear, informative title
                labs(title = paste("ggVenn Diagram -", cell_type)) +
                
                # Ensure consistent, professional appearance
                theme(plot.title = element_text(hjust = 0.5,    # Center the title
                                    size = 14,      # Clear but not dominating
                                    face = "bold"   # Stand out from other text
                                  ),
                      
                  # Add padding around the plot
                  plot.margin = margin(20, 20, 20, 20))
    
    # Save the plot with high resolution for publication quality
    ggsave(file.path(output_dir_base, "Filtered_50_cells", "Overlap_analysis", "ggVennDiagram", paste0("ggVenn_", cell_type, ".png")), venn_plot, width = 10, height = 10, dpi = 300)
    return(venn_plot)
  }, error = function(e) {
    message(sprintf("Error creating ggVenn plot for %s: %s", 
                    cell_type, e$message))
    return(NULL)
  })
}
```

```{r Excute venndiagram function, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Function to create DEG (Differentially Expressed Gene) sets from input files
# This function processes multiple files containing significant genes and organizes them
# by cell type and comparison condition
create_deg_sets <- function(input_dir) {
  # Look for files containing significant genes
  # The pattern matches files named like "Significant_genes_*.csv"
  sig_gene_files <- list.files(input_dir, pattern = "Significant_genes_.+\\.csv$", full.names = TRUE)
  
  # Verify that we found some files to process
  if (length(sig_gene_files) == 0) {
    stop("No significant gene files found in input directory")
  }
  
  # Initialize the main data structure to store DEG sets
  # This will be organized hierarchically: cell_type -> comparison -> genes
  deg_sets <- list()
  
  # Process each file containing significant genes
  for (file in sig_gene_files) {
    tryCatch({
      # Extract information from the file name
      # We parse the file name to get cell type and comparison information
      file_name <- basename(file)
      parts <- strsplit(gsub("Significant_genes_|.csv", "", file_name), "_")[[1]]
      cell_type <- parts[1]  # First part is cell type
      comparison_name <- paste(parts[-1], collapse = "_")  # Rest is comparison name
      
      # Read the gene list from the file
      sig_genes <- read.csv(file)
      
      # Verify the file has the expected structure
      if (!"gene" %in% colnames(sig_genes)) {
        warning(paste("No 'gene' column in file:", file_name))
        next
      }
      
      # Create nested structure if it doesn't exist
      if (is.null(deg_sets[[cell_type]])) {
        deg_sets[[cell_type]] <- list()
      }
      
      # Store the gene list and log the processing
      deg_sets[[cell_type]][[comparison_name]] <- sig_genes$gene
      message(sprintf("Processed %s: %d genes", file_name, length(sig_genes$gene)))
    }, error = function(e) {
      warning(sprintf("Error processing file %s: %s", file, e$message))
    })
  }
  return(deg_sets)
}

# Function to identify genes that are exclusively differentially expressed in each condition
# This helps identify condition-specific responses
create_exclusive_deg_sets <- function(deg_sets) {
  # Initialize storage for exclusive gene sets
  exclusive_sets <- list()
  
  # Process each cell type's data separately
  for (cell_type in names(deg_sets)) {
    exclusive_sets[[cell_type]] <- list()
    conditions <- deg_sets[[cell_type]]
    
    # If there's only one condition, no need to find exclusive genes
    if (length(conditions) <= 1) {
      exclusive_sets[[cell_type]] <- conditions
      next
    }
    
    # For each condition, find genes that are unique to that condition
    for (condition_name in names(conditions)) {
      # Get genes for current condition
      current_genes <- conditions[[condition_name]]
      
      # Get all other conditions for comparison
      other_conditions <- conditions[names(conditions) != condition_name]
      
      # Combine genes from all other conditions
      other_genes <- unique(unlist(other_conditions))
     
       # Find genes that only appear in the current condition
      exclusive_genes <- setdiff(current_genes, other_genes)
      
      # Store results if we found exclusive genes
      if (length(exclusive_genes) > 0) {
        exclusive_sets[[cell_type]][[condition_name]] <- exclusive_genes
        # Log the results for monitoring
        message(sprintf("%s - %s: %d exclusive genes out of %d total", 
                        cell_type, condition_name, 
                        length(exclusive_genes), length(current_genes)))
      }
    }
  }
  return(exclusive_sets)
}

# Function to process and summarize DEG analysis files
# This provides an overview of the differential expression results
process_files <- function(input_dir, pattern, type) {
  # Create a framework to store our results
  # This will track file information and gene counts
  results <- data.frame(File = character(),
                        Cell_Type = character(),
                        Comparison = character(),
                        Total_Genes = integer(),
                        stringsAsFactors = FALSE)
  
  # Find all relevant files in the input directory
  files <- list.files(input_dir, pattern = pattern, full.names = TRUE)
  
  # Process each file and extract key information
  for (file in files) {
    tryCatch({
      # Parse the file name to extract metadata
      file_name <- basename(file)
      parts <- strsplit(gsub(paste0(type, "_results_|Significant_genes_|\\.csv"), "", file_name), "_")[[1]]
      
      # Extract cell type and comparison information
      cell_type <- parts[1]
      comparison <- paste(parts[-1], collapse = "_")
      
      # Read the file and count total genes
      data <- read.csv(file)
      total_genes <- nrow(data)
      
      # Add this file's information to our results
      results <- rbind(results, data.frame(
                                File = file_name,
                                Cell_Type = cell_type,
                                Comparison = comparison,
                                Total_Genes = total_genes,
                                stringsAsFactors = FALSE))
    }, error = function(e) {
      warning(sprintf("Error processing file %s: %s", file, e$message))
    })
  }
  return(results)
}


# Create sets
deg_sets <- create_deg_sets((file.path(output_dir_base, "Filtered_50_cells", "Sig_gene")))
exclusive_deg_sets <- create_exclusive_deg_sets(deg_sets)

# Process files (using your existing process_files function)
deg_results <- process_files((file.path(output_dir_base, "Filtered_50_cells", "DE_gene")), "DE_results_.+\\.csv$", "DEG_all")
sig_results <- process_files((file.path(output_dir_base, "Filtered_50_cells", "Sig_gene")), "Significant_genes_.+\\.csv$", "sig")

# save 
saveRDS(deg_sets,file.path(output_dir_base, "RDS_mid", "de_sets.rds"))
saveRDS(exclusive_deg_sets,file.path(output_dir_base, "RDS_mid", "exclusive_deg_sets.rds"))
saveRDS(deg_results,file.path(output_dir_base, "RDS_mid", "de_results.rds"))
saveRDS(sig_results,file.path(output_dir_base, "RDS_mid", "sig_results.rds"))

# For each cell type in your data:
for (cell_type in names(deg_sets)) {
  # Create a ggVenn plot
  create_ggvenn_plot(deg_sets[[cell_type]], cell_type, output_dir_base)
  
  # Create a traditional Venn diagram
  create_venn_diagram(deg_sets[[cell_type]], cell_type, output_dir_base)
  
  # Create an Euler diagram
  create_euler_plot(deg_sets[[cell_type]], cell_type, output_dir_base)
}
```

```{r Gene behavior}
# get file list
output_dir_base <-"~/PTZ_ATAC_scRNA_072024/WIP/0428_run"
sig_gene_files <- list.files(path = file.path(output_dir_base, "Filtered_50_cells", "Sig_gene"), pattern = "Significant_genes_.+\\.csv$", full.names = TRUE)

# combine list
deg_list <- lapply(
  sig_gene_files, 
  function(file) {
    read_csv(file) %>%
    mutate(condition = paste(cell_type, comparison, sep = "_"))
    }
  )

deg_all <- bind_rows(deg_list)

deg_top10 <- 
  deg_all %>% 
  group_by(condition) %>%
  arrange(p_val_adj, .by_group = TRUE) %>%
  slice_head(n=10) %>%
  dplyr::select(avg_log2FC, p_val_adj, gene, condition, cell_type, comparison) %>%
  mutate(comparison = factor(comparison, levels = c(
    "PTZvsSAL_1hr",
    "PTZvsSAL_24hr",
    "24hrvs1hr_PTZ", 
    "24hrvs1hr_SAL"
  )))

# plot
plot <- ggplot(deg_top10, aes(x = comparison, y = avg_log2FC, group = gene, color = gene), label = T) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "Gene-wise avg_log2FC Across Timepoints",
       x = "Comparison Group",
       y = "avg_log2FC (log2)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~ cell_type, scales = "free_y") + 
  guides(color = "none")

ggsave(filename = file.path(output_dir_base, "Filtered_50_cells", "Plots", "Gene_Behavior", "LinePlot_all_by_pattern.png"), plot, width = 12, height =12, dpi = 300)

# more
deg_wide <- deg_all %>%
  # filter(comparison %in% c("PTZvsSAL_1hr", "PTZvsSAL_24hr", "24hrvs1hr_PTZ")) %>%
  dplyr::select(gene, cell_type, comparison, avg_log2FC) %>%
  pivot_wider(
    names_from = comparison,
    values_from = avg_log2FC
  )

deg_wide <- deg_wide %>%
  mutate(
    pattern = case_when(
      PTZvsSAL_1hr > 0 & PTZvsSAL_24hr > 0 ~ "Increase maintain",
      PTZvsSAL_1hr > 0 & PTZvsSAL_24hr < 0 ~ "Increase then Reversal",
      PTZvsSAL_1hr > 0 & is.na(PTZvsSAL_24hr) ~ "Increase then Baseline",
      PTZvsSAL_1hr < 0 & PTZvsSAL_24hr < 0 ~ "Sustained Decrease",
      PTZvsSAL_1hr < 0 & PTZvsSAL_24hr > 0 ~ "Decrease then Reversal",
      PTZvsSAL_1hr < 0 & is.na(PTZvsSAL_24hr) ~ "Decrease then Baseline",
      is.na(PTZvsSAL_1hr) & PTZvsSAL_24hr > 0 ~ "Late Upregulation",
      is.na(PTZvsSAL_1hr) & PTZvsSAL_24hr < 0 ~ "Late Downregulation",
      TRUE ~ "Other"
    ))

bar <- deg_wide %>%
  dplyr::count(pattern, sort = TRUE) %>%
  ggplot(aes(x = reorder(pattern, n), y = n, fill = pattern)) +
  geom_col() +
  coord_flip() +
  theme_minimal() +
  labs(title = "Gene Count per Pattern", x = "Pattern", y = "Gene Count")

ggsave(filename = file.path(output_dir_base, "Filtered_50_cells", "Plots", "Gene_Behavior", "BarPlot_all_by_pattern.png"), bar, width = 12, height =12, dpi = 300)

bar_cell <- deg_wide %>%
  dplyr::count(cell_type, pattern, sort = TRUE) %>%
  ggplot(aes(x = reorder(pattern, n), y = n, fill = pattern)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  theme_minimal() +
  facet_wrap(~ cell_type, scales = "free_y") +
  labs(title = "Gene Count per Pattern by Cell Type", x = "Pattern", y = "Gene Count")

ggsave(filename = file.path(output_dir_base, "Filtered_50_cells", "Plots", "Gene_Behavior", "BarPlot_all_by_pattern_cell.png"), bar_cell, width = 16, height =12, dpi = 300)

#  Injection point (baseline)
baseline_point <- deg_wide %>%
  distinct(gene, cell_type, pattern) %>%
  mutate(
    timepoint = "Injection",
    avg_log2FC = 0
  )

# 2. Long-format main timepoints
deg_long <- deg_wide %>%
  pivot_longer(
    cols = c("PTZvsSAL_1hr", "PTZvsSAL_24hr"),
    names_to = "comparison",
    values_to = "avg_log2FC"
  ) %>%
  mutate(
    timepoint = case_when(
      comparison == "PTZvsSAL_1hr" ~ "PTZ_1hr",
      comparison == "PTZvsSAL_24hr" ~ "PTZ_24hr"
    )
  ) %>%
  dplyr::select(gene, cell_type, pattern, timepoint, avg_log2FC)

deg_long_full <- bind_rows(baseline_point, deg_long) %>%
  arrange(gene, cell_type, timepoint) %>%
  mutate(group_id = paste(gene, cell_type, sep = "_"))

deg_long_full_filtered <- deg_long_full %>%
  filter(pattern != "Other")

cell <- ggplot(deg_long_full_filtered, aes(x = timepoint, y = avg_log2FC, group = group_id, color = pattern)) +
  geom_line(alpha = 0.7, linewidth = 1) +
  geom_point(size = 2) +
  facet_wrap(~ cell_type, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Gene Expression Over Time by Cell Type",
    x = "Timepoint",
    y = "avg_log2FC (PTZ vs SAL)"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray")

ggsave(filename = file.path(output_dir_base, "Filtered_50_cells", "Plots", "Gene_Behavior", "LinePlot_cell.png"), cell, width = 16, height =12, dpi = 300)

pattern <- ggplot(deg_long_full_filtered, aes(x = timepoint, y = avg_log2FC, group = pattern)) +
  geom_line(aes(color = pattern), alpha = 0.5) +
  facet_grid(cell_type ~ pattern, scales = "free_y") +
  theme_minimal() +
  labs(title = "Gene Expression by Pattern and Cell Type",
       x = "Timepoint", y = "avg_log2FC")

ggsave(filename = file.path(output_dir_base, "Filtered_50_cells", "Plots", "Gene_Behavior", "LinePlot_grid.png"), pattern, width = 16, height =12, dpi = 300)

# simplified
pattern_summary_by_cell <- deg_long_full_filtered %>%
  group_by(cell_type, pattern, timepoint) %>%
  summarise(
    mean_log2FC = mean(avg_log2FC, na.rm = TRUE),
    gene_count = n(),
    .groups = "drop"
  )

pattern_summary_by_cell <- pattern_summary_by_cell %>%
  mutate(timepoint = factor(timepoint, levels = c("Injection", "PTZ_1hr", "PTZ_24hr")))

pattern_plot_by_cell <- ggplot(pattern_summary_by_cell, aes(x = timepoint, y = mean_log2FC, group = pattern, color = pattern)) +
  geom_line(linewidth = 1) +
  geom_point(aes(size = gene_count)) +
  scale_size_continuous(range = c(2, 8)) +
  facet_wrap(~ cell_type, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Average Gene Expression per Pattern Over Time by Cell Type",
    x = "Timepoint",
    y = "Mean avg_log2FC",
    size = "Gene Count",
    color = "Pattern"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

ggsave(filename = file.path(output_dir_base, "Filtered_50_cells", "Plots", "Gene_Behavior", "LinePlot_agg.png"), pattern_plot_by_cell, width = 16, height =12, dpi = 300)

```

```{r GO analysis setup, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# plotting matrics
# count - Good for finding major pathways, Biased toward large GO terms
# fold enrichment - Shows relative enrichment compared to background, Good for finding specific/unique processes, Can highlight rare but important termsSmall terms can have high fold enrichment by chance
#                   Fold Enrichment = (n_genes_in_term/total_genes_in_set) / (n_background_genes_in_term/total_background_genes) = (GeneRatio) / (BgRatio)
# p value - Higher values indicate stronger statistical significance, Very large gene sets can be significant but have small effect sizes, Small p-values might arise from large sample sizes rather than strong effects
# ratio (effect size) - Small gene sets can have high ratios by chance, Doesn't account for statistical uncertainty
# comined score - Prioritizes terms that are both statistically significant AND have strong effect sizes, Down weights terms that are only significant or only have high ratios, Helps find biologically meaningful enrichments
#                 combined_score = -log10(p.adjust) * GeneRatio_numeric
#   Count - How many genes are involved?
#   Fold Enrichment: How specific/unique is this enrichment?
#   P-value: How statistically reliable is this finding?
# Get list of files
input_dir <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Sig_gene"

sig_gene_files <- list.files(path = input_dir, pattern = "Significant_genes_.+\\.csv$", full.names = TRUE)

counts_matrix <- GetAssayData(object = combined_merged, assay = "RNA", layer = "counts")
bg_gene <- rownames(counts_matrix)[Matrix::rowSums(counts_matrix > 0) > 10]

# Create output directories 
output_dir_base <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/GO_Analysis"

output_dir_csv <- file.path(output_dir_base, "csv/")
output_dir_rds <- file.path(output_dir_base, "enrichRobject/")
output_dir_dot <- file.path(output_dir_base, "GO_plot/DotPlot/")
output_dir_cnetplot <- file.path(output_dir_base, "GO_plot/Cnetplots/")
output_dir_rrvocsv <- file.path(output_dir_base, "SemanticSimilarity/")
output_dir_rrvo <- file.path(output_dir_base, "GO_plot/rrvgo/")
output_dir_categorized <- file.path(output_dir_base, "/GO_plot/Categorized/") # Replace with your output folder path

dir.create(output_dir_categorized, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_base, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_csv, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_rds, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_dot, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_cnetplot, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_rrvo, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_rrvocsv, recursive = TRUE, showWarnings = FALSE)
```

```{r GO analysis loop, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# loop for files in sig_gene folder
for (file in sig_gene_files) {
  # Extract cell type and comparison name
  file_name <- basename(file)
  parts <- strsplit(gsub("Significant_genes_|.csv", "", file_name), "_")[[1]]
  cell_type <- parts[1]
  comparison_name <- paste(parts[-1], collapse = "_")
  print(paste("Processing GO analysis for", cell_type, "-", comparison_name))
  
  # Read significant genes
  sig_files <- read.csv(file)
  
  # Extract gene list, removing NAs and empty values
  sig_genes <- sig_files$gene
  sig_genes <- sig_genes[!is.na(sig_genes) & sig_genes != ""]

  if (length(sig_genes) == 0) {
    message(sprintf("Skipping file %s: No valid genes for GO analysis.", file))
    next
  }
  
  # Perform GO enrichment analysis
  go_results <- tryCatch({
    enrichGO(
      gene = sig_genes,
      OrgDb = org.Mm.eg.db,
      keyType = "SYMBOL",
      ont = "BP",
      universe = bg_gene,
      pAdjustMethod = "bonferroni",
      pvalueCutoff = 0.05,
      qvalueCutoff = 0.05
    )
  }, error = function(e) {
    message(sprintf("Error in GO enrichment for %s - %s: %s", cell_type, comparison_name, e$message))
    return(NULL)
  })

  # Ensure go_results has valid data
  if (is.null(go_results) || !("result" %in% slotNames(go_results)) || nrow(go_results@result) == 0) {
    message(sprintf("Skipping file %s: No enriched GO terms found.", file))
    next
  }

  go_results_df <- go_results@result  # Convert S4 object to data frame

  # Ensure go_results_df is valid
  if (!is.data.frame(go_results_df) || nrow(go_results_df) < 2) {
    message(sprintf("Skipping file %s: Not enough valid GO terms to proceed.", file))
    next
  }

  # Compute additional columns
  go_results_df <- go_results_df %>%
    mutate(
      log10_p_adjust = -log10(p.adjust),
      GeneRatio_numeric = sapply(strsplit(GeneRatio, "/"), function(x) as.numeric(x[1])/as.numeric(x[2])),
      BgRatio_numeric = sapply(strsplit(BgRatio, "/"), function(x) as.numeric(x[1])/as.numeric(x[2])),
      fold_enrichment = GeneRatio_numeric / BgRatio_numeric,
      Pvalue_base_enrichment_score = fold_enrichment * -log10(p.adjust)
    )
  
  # Save original GO results
  # write.csv(go_results_df, file = file.path(output_dir_csv, paste0("GO_results_", cell_type, "_", comparison_name, ".csv")), row.names = FALSE)

  # Select top terms (Check before proceeding)
  if (nrow(go_results_df) >= 2) {
    top_terms <- go_results_df %>% arrange(p.adjust) %>% head(20)
  } else {
    message("No GO terms found after sorting, skipping visualization.")
    next
  }
  
  # **Generate Cnetplot only if enough terms exist**
  # if (nrow(top_terms) >= 2) {
  #   cnet_plot <- tryCatch({
  #     cnetplot(go_results,
  #              showCategory = min(20, nrow(top_terms)),
  #              circular = TRUE,
  #              node_label = "gene") +
  #       ggtitle(paste("GO Network:", cell_type, "-", comparison_name)) +
  #       theme_minimal()
  #   }, error = function(e) {
  #     message(sprintf("Skipping cnetplot for %s - %s: Error encountered -> %s", cell_type, comparison_name, e$message))
  #     return(NULL)
  #   })
  # 
  #   if (!is.null(cnet_plot)) {
  #     ggsave(file.path(output_dir_cnetplot, paste0("cnetplot_", cell_type, "_", comparison_name, ".png")), 
  #            cnet_plot, width = 12, height = 10, dpi = 300)
  #     message(sprintf("Successfully created cnetplot for %s - %s", cell_type, comparison_name))
  #   }
  # } else {
  #   message(sprintf("Skipping cnetplot for %s - %s: Not enough GO terms.", cell_type, comparison_name))
  # }

  # **GO Similarity Analysis (RRVGO)**
  if (nrow(go_results_df) > 1 && length(unique(go_results_df$ID)) > 1) {

    similarity <- tryCatch({
      calculateSimMatrix(
        go_results_df$ID,
        orgdb = org.Mm.eg.db,
        ont = "BP",
        method = "Rel"
      )
    }, error = function(e) {
      message(sprintf("Error computing similarity matrix for %s - %s: %s", cell_type, comparison_name, e$message))
      return(NULL)
    })

    if (!is.null(similarity) && length(similarity) > 1) {

      reduced_terms <- tryCatch({
        reduceSimMatrix(
          similarity,
          scores = setNames(-log10(go_results_df$p.adjust), go_results_df$ID),
          threshold = 0.5,
          orgdb = org.Mm.eg.db
        )
      }, error = function(e) {
        message(sprintf("Error reducing GO terms for %s - %s: %s", cell_type, comparison_name, e$message))
        return(NULL)
      })

      if (!is.null(reduced_terms) && nrow(reduced_terms) > 1) {
        go_results_df <- go_results_df[go_results_df$ID %in% reduced_terms$go, ]

        # Save outputs
        write.csv(reduced_terms, file = file.path(output_dir_rrvocsv, paste0("Reduced_GO_terms_", cell_type, "_", comparison_name, ".csv")), row.names = FALSE)

        # **Generate RRVGO Plots**
        png(file = file.path(output_dir_rrvo, paste0(cell_type, "_", comparison_name, "_treemap.png")), width = 12, height = 12, units = "in", res = 300)
        print(treemapPlot(reduced_terms))
        dev.off()
      }
    }
  }

  # # **Generate Dotplot**
  # go_plot <- ggplot(top_terms, aes(
  #   x = reorder(Description, -log10(p.adjust)),  
  #   y = -log10(p.adjust),
  #   fill = fold_enrichment,
  #   size = Count)) +
  #   geom_point(shape = 21) +  
  #   coord_flip() +  
  #   scale_fill_viridis(option = "magma") +  
  #   theme_minimal() +
  #   labs(
  #     title = paste("Top GO Terms:", cell_type, "-", comparison_name),
  #     x = "GO Term Description",
  #     y = "-log10(adjusted p-value)",
  #     fill = "Fold Enrichment",
  #     size = "Gene Count")
  # 
  # ggsave(file.path(output_dir_dot, paste0("GO_dotplot_", cell_type, "_", comparison_name, ".png")), 
  #        go_plot, width = 12, height = 8, dpi = 300)
}
```

```{r CnetPlot only, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# loop for files in sig_gene folder
for (file in sig_gene_files) {
  # Extract cell type and comparison name
  file_name <- basename(file)
  parts <- strsplit(gsub("Significant_genes_|.csv", "", file_name), "_")[[1]]
  cell_type <- parts[1]
  comparison_name <- paste(parts[-1], collapse = "_")
  print(paste("Processing GO analysis for", cell_type, "-", comparison_name))
  
  # Read significant genes
  sig_files <- read.csv(file)
  
  if (length(sig_genes) == 0) {
    message(sprintf("Skipping file %s: No valid genes for GO analysis.", file))
    next  # Move to the next file in the loop
  }
  
  # Ensure the 'gene' column exists
  if (!"gene" %in% colnames(sig_files)) {
    message(sprintf("Skipping file %s: 'gene' column not found.", file))
    next  # Skip this iteration and continue to the next file
  }
  
  # Extract gene list, removing NAs and empty values
  sig_genes <- sig_files$gene
  sig_genes <- sig_genes[!is.na(sig_genes) & sig_genes != ""]
  
  go_results <- enrichGO(
    gene = sig_genes,
    OrgDb = org.Mm.eg.db,
    keyType = "SYMBOL",
    ont = "BP",  # "BP, "MF", "CC" or "ALL"
    pAdjustMethod = "BH", # Benjamini-Hochberg (BH) correction, more stringent = "bonferroni".
    pvalueCutoff = 0.05,
    qvalueCutoff = 0.05
  )
  
  
  # Select top terms
  top_terms <- go_results@result %>% arrange(p.adjust) %>% head(20)
  go_results@result <- go_results@result[go_results@result$ID %in% top_terms$ID, ]
  
  # Ensure `geneID` is properly formatted
  go_results@result$geneID <- as.character(go_results@result$geneID)
  print(head(go_results@result$geneID))
  
  if (nrow(go_results@result) == 0) {
    stop(sprintf("Error: No significant GO terms remain after filtering for %s - %s", cell_type, comparison_name))
  }
  print(head(go_results@result))
  
  # Generate Cnetplot
  cnet_plot <- cnetplot(go_results,
                        showCategory = 20,  # Use top terms
                        circular = TRUE,
                        node_label = "gene") +
    ggtitle(paste("GO Network:", cell_type, "-", comparison_name)) +
    theme_minimal()
  
  # Save Cnetplot
  ggsave(file.path(output_dir_cnetplot, paste0("cnetplot_", cell_type, "_", comparison_name, ".png")), cnet_plot, width = 12, height = 10, dpi = 300)
  message(sprintf("Successfully created cnetplot for %s - %s", cell_type, comparison_name))
}
```

```{r Go analysis up/down separation, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# dir set
input_dir <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/"

# File path and list of files
sig_files <- list.files(file.path(input_dir, "Filtered_50_cells", "Sig_gene"), full.names = T)

output_dir_base <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/GO_Analysis"
output_dir_csv <- file.path(output_dir_base, "csv/")
output_dir_rds <- file.path(output_dir_base, "enrichRobject/")
output_dir_dot <- file.path(output_dir_base, "GO_plot/DotPlot/")
output_dir_cnetplot <- file.path(output_dir_base, "GO_plot/Cnetplots/")
output_dir_rrvocsv <- file.path(output_dir_base, "SemanticSimilarity/")
output_dir_rrvo <- file.path(output_dir_base, "GO_plot/rrvgo/")
output_dir_categorized <- file.path(output_dir_base, "/GO_plot/Categorized/") # Replace with your output folder path

dir.create(output_dir_categorized, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_base, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_csv, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_rds, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_dot, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_cnetplot, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_rrvo, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_rrvocsv, recursive = TRUE, showWarnings = FALSE)

# Get counts matrix go bg gene
combined_merged <- readRDS("~/PTZ_ATAC_scRNA_072024/WIP/0428_run/RDS_mid/combined_merged_atac_work.rds")
counts_matrix <- GetAssayData(combined_merged, assay = "RNA", layer = "counts")

# Filter genes expressed in more than 10 cells
bg_gene <- rownames(counts_matrix)[Matrix::rowSums(counts_matrix > 0) > 10]

file_list  = list
# loop for files in sig_gene folder
for (sig_file in sig_files[12]) {
  # read file
  sig_data <- read.csv(sig_file)
  
  # Extract cell type and comparison name
  sig_file_name <- basename(sig_file)
  parts <- strsplit(gsub("Significant_genes_|.csv", "", sig_file_name), "_")[[1]]
  cell_type <- parts[1]
  comparison_name <- paste(parts[-1], collapse = "_")

  # Extract gene list, removing NAs and empty values
  sig_genes <- sig_data$gene
  sig_genes <- sig_genes[!is.na(sig_genes) & sig_genes != ""]

  if (length(sig_genes) == 0) {
    cat(sprintf("Skipping file %s: No valid genes for GO analysis.", sig_file_name))
    next
  }
  
  # Perform GO enrichment analysis
  go_results <- tryCatch({
    enrichGO(
      gene = sig_genes,
      OrgDb = org.Mm.eg.db,
      keyType = "SYMBOL",
      ont = "BP",
      universe = bg_gene,
      pAdjustMethod = "BH",
      pvalueCutoff = 0.05,
      qvalueCutoff = 0.05
    )
  }, error = function(e) {
    cat(sprintf("Error in GO enrichment for %s - %s: %s", cell_type, comparison_name, e$message))
    return(NULL)
  })
  
  # Ensure go_results has valid data
  if (is.null(go_results) || !("result" %in% slotNames(go_results)) || nrow(go_results@result) == 0) {
    cat(sprintf("Skipping file %s: No enriched GO terms found.", file))
    next
  }
  
  go_results_df <- go_results@result  # Convert S4 object to data frame
  
  # Ensure go_results_df is valid
  if (!is.data.frame(go_results_df) || nrow(go_results_df) < 2) {
    cat(sprintf("Skipping file %s: Not enough valid GO terms to proceed.", file))
    next
  }
  
  # Compute additional columns
  go_results_df <- go_results_df %>%
    mutate(
      log10_p_adjust = -log10(p.adjust),
      GeneRatio_numeric = sapply(strsplit(GeneRatio, "/"), function(x) as.numeric(x[1])/as.numeric(x[2])),
      BgRatio_numeric = sapply(strsplit(BgRatio, "/"), function(x) as.numeric(x[1])/as.numeric(x[2])),
      fold_enrichment = GeneRatio_numeric / BgRatio_numeric,
      Pvalue_base_enrichment_score = fold_enrichment * -log10(p.adjust)
    )
  
  # Save original GO results
  write.csv(go_results_df, file = file.path(output_dir_csv, paste0("GO_results_", cell_type, "_", comparison_name, ".csv")), row.names = FALSE)
  
  # Select top terms (Check before proceeding)
  top_terms <- go_results_df %>% filter(pvalue < 0.05) %>% arrange(pvalue) %>% head(20)
  if (nrow(top_terms) < 1) {
    cat(sprintf("Not enough GO terms < 0.05 in %s - %s. Skipping dotplot.", cell_type, comparison_name))
    next
  }
  
  # **Generate Dotplot**
  go_plot <- ggplot(top_terms, aes(
    x = reorder(Description, log10_p_adjust),  
    y = log10_p_adjust,
    fill = fold_enrichment,
    size = Count)) +
    geom_point(shape = 21) +  
    coord_flip() +  
    scale_fill_viridis(option = "magma") +  
    theme_minimal() +
    labs(
      title = paste("Top GO Terms:", cell_type, "-", comparison_name),
      x = "GO Term Description",
      y = "log10_p_adjust",
      fill = "Fold Enrichment",
      size = "Gene Count")
  
  ggsave(file.path(output_dir_dot, paste0("GO_dotplot_", cell_type, "_", comparison_name, ".png")), 
         go_plot, width = 12, height = 8, dpi = 300)
  
  # **Generate Cnetplot only if enough terms exist**
  if (nrow(top_terms) >= 2) {
    cnet_plot <- tryCatch({
      cnetplot(go_results,
               showCategory = min(20, nrow(top_terms)),
               circular = TRUE,
               node_label = "gene") +
        ggtitle(paste("GO Network:", cell_type, "-", comparison_name)) +
        theme_minimal()
    }, error = function(e) {
      message(sprintf("Skipping cnetplot for %s - %s: Error encountered -> %s", cell_type, comparison_name, e$message))
      return(NULL)
    })

    if (!is.null(cnet_plot)) {
      ggsave(file.path(output_dir_cnetplot, paste0("cnetplot_", cell_type, "_", comparison_name, ".png")),
             cnet_plot, width = 12, height = 10, dpi = 300)
      message(sprintf("Successfully created cnetplot for %s - %s", cell_type, comparison_name))
    }
  } else {
    message(sprintf("Skipping cnetplot for %s - %s: Not enough GO terms.", cell_type, comparison_name))
  }

  # **GO Similarity Analysis (RRVGO)**
  if (nrow(go_results_df) > 1 && length(unique(go_results_df$ID)) > 1) {

    similarity <- tryCatch({
      calculateSimMatrix(
        go_results_df$ID,
        orgdb = org.Mm.eg.db,
        ont = "BP",
        method = "Rel"
      )
    }, error = function(e) {
      message(sprintf("Error computing similarity matrix for %s - %s: %s", cell_type, comparison_name, e$message))
      return(NULL)
    })

    if (!is.null(similarity) && length(similarity) > 1) {

      reduced_terms <- tryCatch({
        reduceSimMatrix(
          similarity,
          scores = setNames(-log10(go_results_df$p.adjust), go_results_df$ID),
          threshold = 0.5,
          orgdb = org.Mm.eg.db
        )
      }, error = function(e) {
        message(sprintf("Error reducing GO terms for %s - %s: %s", cell_type, comparison_name, e$message))
        return(NULL)
      })

      if (!is.null(reduced_terms) && nrow(reduced_terms) > 1) {
        go_results_df <- go_results_df[go_results_df$ID %in% reduced_terms$go, ]

        # Save outputs
        write.csv(reduced_terms, file = file.path(output_dir_rrvocsv, paste0("Reduced_GO_terms_", cell_type, "_", comparison_name, ".csv")), row.names = FALSE)

        # **Generate RRVGO Plots**
        png(file = file.path(output_dir_rrvo, paste0(cell_type, "_", comparison_name, "_treemap.png")), width = 12, height = 12, units = "in", res = 300)
        print(treemapPlot(reduced_terms))
        dev.off()
      }
    }
  }
}

```

```{r Gene frequency fucntion in GO terms, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Function to count GO terms per gene and generate reports
count_gene_go_terms <- function(input_dir, output_dir_plot, output_dir_csv, output_file) {
  
  # Read all GO result files
  go_files <- list.files(input_dir, pattern = ".csv$", full.names = TRUE)
  
  # Create data frames to store results for each condition
  all_counts <- data.frame()
  all_counts_top <- data.frame()
  
  for (file in go_files) {
    # Extract condition name from filename
    condition <- gsub(".csv", "", basename(file))
    
    # Read GO results
    go_data <- read_csv(file)
    
    # Skip files with no data
    if (nrow(go_data) == 0) {
      message(sprintf("Skipping file %s: No data", file))
      next
    }
    
    # Ensure geneID column exists
    if (!"geneID" %in% colnames(go_data)) {
      message(sprintf("Skipping file %s: Missing 'geneID' column", file))
      next
    }
    
    # Ensure geneID is character type
    go_data$geneID <- as.character(go_data$geneID)
    
    # Select top 20 GO terms by adjusted p-value
    top_terms <- go_data %>%
      arrange(p.adjust) %>%
      slice_min(order_by = p.adjust, n = min(20, nrow(go_data)))
    
    # Convert geneID column from merged string format to long format
    gene_go_pairs <- go_data %>%
      dplyr::select(ID, geneID) %>%
      separate_rows(geneID, sep = "/")  # Expands "Tuba1a/Tubb5" to multiple rows
    
    # Count occurrences of each gene across GO terms
    gene_counts <- table(gene_go_pairs$geneID)
    go_id_map <- gene_go_pairs  # Store gene-to-GO term mapping
    
    # Repeat for top 20 GO terms
    gene_go_pairs_top <- top_terms %>%
      dplyr::select(ID, geneID) %>%
      separate_rows(geneID, sep = "/")
    
    gene_counts_top <- table(gene_go_pairs_top$geneID)
    go_id_map_top <- gene_go_pairs_top
    
    # Convert counts to data frames
    count_df <- data.frame(
      condition = condition,
      gene = names(gene_counts),
      go_term_count = as.numeric(gene_counts)
    ) %>% merge(go_id_map, by.x = "gene", by.y = "geneID", all.x = TRUE)
    
    count_df_top <- data.frame(
      condition = condition,
      gene = names(gene_counts_top),
      go_term_count = as.numeric(gene_counts_top)
    ) %>% merge(go_id_map_top, by.x = "gene", by.y = "geneID", all.x = TRUE)
    
    # Append results to main data frames
    all_counts <- bind_rows(all_counts, count_df)
    all_counts_top <- bind_rows(all_counts_top, count_df_top)
    
    # Analyze gene frequency for bar plots and gene reports
    gene_freq_df <- data.frame(gene = names(gene_counts), frequency = as.numeric(gene_counts)) %>%
      arrange(desc(frequency))
    
    # Create bar plot for top 30 genes
    plot <- ggplot(head(gene_freq_df, 30), aes(x = reorder(gene, frequency), y = frequency)) +
      geom_bar(stat = "identity", fill = "steelblue") +
      geom_text(aes(label = frequency), hjust = -0.2, size = 3.5) +  # Add count labels
      coord_flip() +
      labs(title = paste("Top 30 Genes by GO Term Frequency -", condition),
           x = "Gene",
           y = "Number of GO Terms") +
      theme_minimal() +
      theme(plot.title = element_text(size = 12, face = "bold"), axis.text = element_text(size = 10))
    
    # Save bar plot
    ggsave(filename = file.path(output_dir_plot, paste0("gene_frequency_", condition, ".png")), 
           plot = plot, width = 10, height = 8, dpi = 300, bg = "white")
    
    # Create detailed gene report
    gene_report <- data.frame()
    
    for (gene in unique(gene_go_pairs$geneID)) {
      # Extract all GO terms for the gene
      gene_terms <- go_data %>%
        filter(grepl(paste0("\\b", gene, "\\b"), geneID)) %>%
        dplyr::select(ID, Description, p.adjust)
      
      # Create report entry
      report_entry <- data.frame(
        gene = gene,
        frequency = gene_counts[gene],
        go_terms = paste(
          paste0(
            gene_terms$Description, " (", gene_terms$ID,
            ", p=", formatC(gene_terms$p.adjust, format = "e", digits = 2), ")"
          ),
          collapse = "; "
        )
      )
      gene_report <- bind_rows(gene_report, report_entry)
    }
    
    # Sort gene report by frequency
    gene_report <- gene_report %>% arrange(desc(frequency))
    
    # Save gene report
    write_csv(gene_report, file.path(output_dir_csv, paste0("gene_report_", condition, ".csv")))
  }
  
  # Write overall results to CSV
  write_csv(all_counts, file.path(input_dir, "gene_go_term_counts.csv"))
  write_csv(all_counts_top, file.path(input_dir, "gene_go_term_counts_top.csv"))
  
  # Combine all gene reports into one file
  file_list <- list.files(path = output_dir_csv, pattern = "*.csv", full.names = TRUE)
  
  combined_df <- lapply(file_list, function(file) {
    df <- read_csv(file)
    df$Source_File <- basename(file)  # Track source file
    return(df)
  }) %>% bind_rows()
  
  # Save combined results
  write_csv(combined_df, output_file)
  
  # Return results as a list
  return(list(all_counts = all_counts, all_counts_top = all_counts_top))
}

# Function to count gene occurrences and create a gene report for the top 20 GO terms
count_gene_top20_with_report <- function(input_dir, output_dir_plot, output_dir_csv, output_file) {
  
  # Read all GO result files
  go_files <- list.files(input_dir, pattern = ".csv$", full.names = TRUE)
  
  # Create a data frame to store results
  all_counts_top <- data.frame()
  
  for (file in go_files) {
    # Extract condition name from filename
    condition <- gsub(".csv", "", basename(file))
    
    # Read GO results
    go_data <- read_csv(file)
    
    # Skip files with no data
    if (nrow(go_data) == 0) {
      message(sprintf("Skipping file %s: No data", file))
      next
    }
    
    # Ensure 'geneID' column exists
    if (!"geneID" %in% colnames(go_data)) {
      message(sprintf("Skipping file %s: Missing 'geneID' column", file))
      next
    }
    
    # Ensure geneID is character type
    go_data$geneID <- as.character(go_data$geneID)
    
    # Select the top 20 GO terms by adjusted p-value
    top_terms <- go_data %>%
      arrange(p.adjust) %>%
      slice_min(order_by = p.adjust, n = min(20, nrow(go_data)))
    
    # Convert geneID column from merged string format to long format (only for top 20 GO terms)
    gene_go_pairs_top <- top_terms %>%
      dplyr::select(ID, Description, p.adjust, geneID) %>%
      separate_rows(geneID, sep = "/")  # Expands "Tuba1a/Tubb5" into separate rows
    
    # Count occurrences of each gene across the top 20 GO terms
    gene_counts_top <- table(gene_go_pairs_top$geneID)
    
    # Convert counts to a data frame
    count_df_top <- data.frame(
      condition = condition,
      gene = names(gene_counts_top),
      go_term_count = as.numeric(gene_counts_top)
    )
    
    # Append results to main data frame
    all_counts_top <- bind_rows(all_counts_top, count_df_top)
    
    # Analyze gene frequency for bar plots
    gene_freq_df <- count_df_top %>% arrange(desc(go_term_count))
    
    # Create bar plot for top 30 genes
    plot <- ggplot(head(gene_freq_df, 30), aes(x = reorder(gene, go_term_count), y = go_term_count)) +
      geom_bar(stat = "identity", fill = "steelblue") +
      geom_text(aes(label = go_term_count), hjust = -0.2, size = 3.5) +  # Add count labels
      coord_flip() +
      labs(title = paste("Top 30 Genes in Top 20 GO Terms -", condition),
           x = "Gene",
           y = "Number of GO Terms") +
      theme_minimal() +
      theme(plot.title = element_text(size = 12, face = "bold"), axis.text = element_text(size = 10))
    
    # Save bar plot
    ggsave(filename = file.path(output_dir_plot, paste0("gene_frequency_top20_", condition, ".png")), 
           plot = plot, width = 10, height = 8, dpi = 300, bg = "white")
    
    # Generate detailed gene report for top 20 GO terms
    gene_report <- data.frame()
    
    for (gene in unique(gene_go_pairs_top$geneID)) {
      # Extract GO terms associated with the gene
      gene_terms <- gene_go_pairs_top %>%
        filter(geneID == gene) %>%
        dplyr::select(ID, Description, p.adjust)
      
      # Create report entry
      report_entry <- data.frame(
        gene = gene,
        frequency = gene_counts_top[gene],
        go_terms = paste(
          paste0(
            gene_terms$Description, " (", gene_terms$ID,
            ", p=", formatC(gene_terms$p.adjust, format = "e", digits = 2), ")"
          ),
          collapse = "; "
        )
      )
      gene_report <- bind_rows(gene_report, report_entry)
    }
    
    # Sort gene report by frequency
    gene_report <- gene_report %>% arrange(desc(frequency))
    
    # Save gene report
    write_csv(gene_report, file.path(output_dir_csv, paste0("gene_report_top20_", condition, ".csv")))
  }
  
  # Write overall top gene counts to CSV
  write_csv(all_counts_top, file.path(output_dir_csv, "gene_go_term_counts_top20.csv"))
  
  # Return as list
  return(all_counts_top)
}
```

```{r Excute function and save - gene frequency in GO, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
go_csv <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/GO_Analysis/csv/"
output_dir_gf_csv <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/GO_Analysis/Gene_frequency/summary/"
output_dir_gf_plot <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/GO_Analysis/Gene_frequency/plots/"
output_file <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/GO_Analysis/Gene_frequency/summary/gene_combined.csv"
output_file_top20 <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/GO_Analysis/Gene_frequency/summary/gene_combined_top20.csv"

# Create necessary directories
dir.create(output_dir_gf_plot, recursive = TRUE, showWarnings = FALSE)
dir.create(output_dir_gf_csv, recursive = TRUE, showWarnings = FALSE)

# Run the function
count_gene_go_terms(input_dir = go_csv, 
                    output_dir_plot = output_dir_gf_plot,
                    output_dir_csv = output_dir_gf_csv, 
                    output_file = output_file)

# Run the function
count_gene_top20_with_report(input_dir = go_csv, 
                             output_dir_plot = output_dir_gf_plot,
                             output_dir_csv = output_dir_gf_csv, 
                             output_file = output_file_top20)
# volcano_plot <- EnhancedVolcano(de_results,
#                                  lab = de_results$gene,
#                                  x = 'avg_log2FC',
#                                  y = 'p_val_adj',
#                                  title = paste('Volcano plot -', cell_type),
#                                  subtitle = safe_comparison_name,
#                                  pCutoff = 0.05,
#                                  FCcutoff = 0.2,
#                                  pointSize = 1.0,
#                                  labSize = 3.0,
#                                  selectLab = selected_genes)  
```

```{r Volcano with GO gene}

# file read
output_dir_base <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/"
csv_files <- list.files(file.path(output_dir_base,"Filtered_50_cells", "DE_gene"), pattern = "DE_results_.+\\.csv$", full.names = TRUE)

all_counts_top <- read_csv(file.path(output_dir_base, "Filtered_50_cells", "GO_Analysis","Gene_frequency", "summary","gene_go_term_counts_top20.csv"))


# loop
for (csv_file in csv_files) {
  # Extract cell type and comparison name from file name
  file_name <- basename(csv_file)
  parts <- strsplit(gsub("DE_results_|.csv", "", file_name), "_")[[1]]
  cell_type <- parts[1]
  comparison_name <- paste(parts[-1], collapse = "_")
  
  # Replace colons with underscores in comparison name
  safe_comparison_name <- gsub("[:]", "_", comparison_name)
  print(paste("Creating volcano plot for", cell_type, "-", comparison_name))
  
  condition_name <- gsub("DE_results_|.csv", "", file_name)[[1]]
  selected_genes <- all_counts_top %>%
  filter(condition == condition_name) %>%
  pull(gene) %>%
  unique()
  
  # Read CSV file
  de_results <- read.csv(csv_file)
  
  if (nrow(de_results) == 0) {
    next
  } else {
    # Create volcano plot
    volcano_plot <- EnhancedVolcano(de_results,
                                 lab = de_results$gene,
                                 x = 'avg_log2FC',
                                 y = 'p_val_adj',
                                 title = paste('Volcano plot -', cell_type),
                                 subtitle = safe_comparison_name,
                                 pCutoff = 0.05,
                                 FCcutoff = 0.2,
                                 pointSize = 1.0,
                                 labSize = 3.0,
                                 selectLab = selected_genes)
    
    # Save volcano plot with safe filename
    plot_file_name <- paste0("Volcano_plot_", cell_type, "_", safe_comparison_name, ".png")
    ggsave(file.path(output_dir_base, "Filtered_50_cells", "Plots","VolcanoPlots_GOgene", plot_file_name), volcano_plot, width = 12, height = 10)
    print(paste("Saved volcano plot:", plot_file_name))
  }}
```

```{r Euler plot for GO gene, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Function to create Euler plots from top 20 GO term gene reports
create_euler_plot_top_genes <- function(input_dir, output_dir) {
  
  # Read all gene report files (Top 20 GO terms only)
  gene_files <- list.files(input_dir, pattern = "^gene_report_top20_.*\\.csv$", full.names = TRUE)
  
  # Create a list to store gene sets per cell type & condition
  gene_sets_per_cell_type <- list()
  
  for (file in gene_files) {
    # Extract filename without path
    file_name <- basename(file)
    
    # Remove prefix and file extension
    file_parts <- strsplit(gsub("gene_report_top20_|.csv", "", file_name), "_")[[1]]
    
    # Identify components from filename
    if (length(file_parts) == 3) {
      # Format: gene_report_top20_OPCs_PTZvsSAL_24hr.csv
      cell_type <- file_parts[1]
      comparison <- file_parts[2]
      time_point <- file_parts[3]
      condition <- paste(comparison, time_point, sep = "_")  # e.g., "PTZvsSAL_24hr"
      
    } else if (length(file_parts) == 3) {
      # Format: gene_report_top20_NdnfRelnInhibitoryInterneurons_24hrvs1hr_PTZ.csv
      cell_type <- file_parts[1]
      comparison <- file_parts[2]  # 24hrvs1hr
      condition <- file_parts[3]  # PTZ or SAL
      
    } else {
      message(sprintf("Skipping file %s: Unexpected filename format.", file))
      next
    }
    
    # Read gene report
    gene_data <- read_csv(file)
    
    # Ensure required columns exist
    if (!("gene" %in% colnames(gene_data))) {
      message(sprintf("Skipping file %s: No 'gene' column found.", file))
      next
    }
    
    # Extract unique genes
    gene_list <- unique(gene_data$gene)
    
    # Debugging: Print extracted genes
    print(sprintf("Extracted %d genes for %s - %s", length(gene_list), cell_type, condition))
    
    # Store gene lists per cell type and condition
    if (!is.list(gene_sets_per_cell_type[[cell_type]])) {
      gene_sets_per_cell_type[[cell_type]] <- list()
    }
    gene_sets_per_cell_type[[cell_type]][[condition]] <- gene_list
  }
  
  # Generate Euler plots for each cell type with all comparisons
  for (cell_type_name in names(gene_sets_per_cell_type)) {
    gene_sets <- gene_sets_per_cell_type[[cell_type_name]]
    
    # Print available conditions for this cell type
    print(sprintf("Available conditions for %s: %s", cell_type_name, paste(names(gene_sets), collapse = ", ")))
    
    # Reduce gene list: Keep only genes appearing in multiple GO terms
    filtered_gene_sets <- lapply(gene_sets, function(genes) {
      gene_counts <- table(genes)
      names(gene_counts[gene_counts >= 1])  # Keep genes appearing in ≥2 GO terms
    })
    
    # Remove empty sets
    filtered_gene_sets <- filtered_gene_sets[lengths(filtered_gene_sets) > 0]
    
    # Print the length of each gene set for debugging
    for (condition_name in names(filtered_gene_sets)) {
      print(sprintf("%s - %s: %d genes", cell_type_name, condition_name, length(filtered_gene_sets[[condition_name]])))
    }
    
    # Ensure there are at least two conditions to compare
    if (length(filtered_gene_sets) >= 1) {
      tryCatch({
        message(sprintf("Creating Euler plot for %s...", cell_type_name))
        
        # Create Euler object
        euler_fit <- euler(filtered_gene_sets)
        
        # Define a color palette
        get_euler_colors <- function(n) {
          colors <- c("#66B2FF", "#FC8D62", "#8DA0CB", "#E78AC3")  # Blue, Orange, Purple, Pink
          return(colors[1:min(n, length(colors))])
        }
        
        # Generate Euler plot
        euler_plot <- plot(euler_fit,
                           quantities = TRUE,
                           fill = get_euler_colors(length(filtered_gene_sets)),
                           edges = list(col = "black", lwd = 1),
                           labels = list(font = 2, cex = 0.8),
                           main = paste("Euler Diagram -", cell_type_name, "(Top 20 GO Terms)"),
                           mar = c(2, 2, 2, 2)
        )
        
        # Save plot
        output_file <- file.path(output_dir, paste0("Euler_TopGenes_", cell_type_name, ".png"))
        png(output_file, width = 10, height = 10, units = "in", res = 300)
        plot(euler_plot)
        dev.off()
        
        message(sprintf("Euler plot saved for cell type: %s", cell_type_name))
        
      }, error = function(e) {
        message(sprintf("Error creating Euler plot for %s: %s", cell_type_name, e$message))
      })
    } else {
      message(sprintf("Skipping Euler plot for cell type: %s (not enough conditions).", cell_type_name))
    }
  }
}
```


```{r Excute function and save, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Set directories
input_dir <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/GO_Analysis/Gene_frequency/summary/"
output_dir_euler <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/GO_Analysis/GO_plot/Euler/"
dir.create(output_dir_euler, recursive = TRUE, showWarnings = FALSE)

# Run the function
create_euler_plot_top_genes(input_dir = input_dir, output_dir = output_dir_euler)
```


```{r}
DE_gene <- list.files(file.path(output_dir_base, "Filtered_50_cells" ,"DE_gene"), pattern = "DE_results_.+\\.csv$", full.names = TRUE)
Go_list <- list.files(file.path(output_dir_base, "Filtered_50_cells" ,"GO_Analysis", "csv"), pattern = "GO_results_.+\\.csv$", full.names = TRUE)

DE_hp <- DE_gene[9:24]
GO_hp <- Go_list[9:24]

# Loop through each DE file and each GO file
candidate_list <- list()

for (i in seq_along(DE_hp)) {
  de_file <- DE_hp[i]
  de_df <- read.csv(de_file, stringsAsFactors = FALSE)
  de_genes <- de_df$gene
  
  # Extract info from DE file name (e.g., "CA1_PTZ_1hr")
  de_info <- gsub("DE_results_|\\.csv", "", basename(de_file))
  
  for (j in seq_along(GO_hp)) {
    go_file <- GO_hp[j]
    # Extract info from GO file name (e.g., "CA1_PTZ_1hr")
    go_info <- gsub("GO_results_|\\.csv", "", basename(go_file))
    
    # Only proceed if the file-derived info matches
    if (de_info == go_info) {
      go_df <- read.csv(go_file, stringsAsFactors = FALSE)
      
      # Loop through each GO term (row) in the GO results file
      for (row in 1:nrow(go_df)) {
        go_term <- go_df$Description[row]
        go_genes <- unlist(strsplit(go_df$geneID[row], "/"))
        
        # Find candidate genes that are common to both the DE list and this GO term
        candidate <- intersect(de_genes, go_genes)
        
        if (length(candidate) > 0) {
          temp_df <- data.frame(
            gene = candidate,
            GO_term = go_term,
            Info = de_info,   # since de_info == go_info
            stringsAsFactors = FALSE
          )
          candidate_list[[length(candidate_list) + 1]] <- temp_df
        }
      }
    }
  }
}

# Combine results into a single data frame
final_candidate_df <- do.call(rbind, candidate_list)
write.csv(final_candidate_df, '~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/GO_Analysis/gene_go_list.csv')

```

```{r KEGG , echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Define path to CSVs
csv_files <- list.files("~/PTZ_ATAC_scRNA_072024/WIP/0609_run/DEG/sig_csv/", pattern = ".csv$", full.names = TRUE)

# Load all CSVs into a list
deg_list <- list()

# add entrezid and keep only more than 10 gene list
for (file in csv_files) {
  deg <- read.csv(file)
  if (nrow(deg) == 0) next
  conversion <- bitr(deg$gene, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
  deg <- inner_join(deg, conversion, by = c("gene" = "SYMBOL"))
  if (nrow(deg) == 0) next
  deg <- dplyr::select(deg, gene, ENTREZID, Regulation, cell_type, comparison)
  up_count <-  sum(deg$Regulation == "UP")
  down_count <- sum(deg$Regulation == "Down")
  
  if (up_count >= 10 | down_count >=10) {
  clean_name <- gsub(".csv", "", basename(file))  # Clean file name
  deg_list[[clean_name]] <- deg
  }
}

# run kegg on up/down gene
kegg_results <- lapply(deg_list, function(df) {
  cell_type <- unique(df$cell_type)
  comparison <- unique(df$comparison)
  
  up_genes <- df$ENTREZID[df$Regulation == "Up"]
  down_genes <- df$ENTREZID[df$Regulation == "Down"]

  list(
    up = enrichKEGG(gene = up_genes, organism = "mmu", pvalueCutoff = 0.05),
    down = enrichKEGG(gene = down_genes, organism = "mmu", pvalueCutoff = 0.05),
    cell_type = cell_type,
    comparison = comparison
  )
})

saveRDS(kegg_results, "~/PTZ_ATAC_scRNA_072024/WIP/0609_run/KEGG/kegg_results.rds")

# visualize
for (dataset in names(kegg_results)) {
  up_reg <- kegg_results[[dataset]]$up
  down_reg <- kegg_results[[dataset]]$down
  
  if (!is.null(up_reg) && nrow(up_reg) > 0) {
    up <- dotplot(kegg_results[[dataset]]$up, showCategory = 15) +
    ggtitle(paste("KEGG_Up - ", dataset))
    ggsave(filename = file.path(output_dir_base, "KEGG", paste0(dataset, "_KEGG_up.png")), plot = up, width = 12, height = 12, dpi = 300)
    }
  
  if (!is.null(down_reg) && nrow(down_reg) > 0) {
    down <- dotplot(kegg_results[[dataset]]$down, showCategory = 15) +
    ggtitle(paste("KEGG_Down - ", dataset))
    ggsave(filename = file.path(output_dir_base, "KEGG", paste0(dataset, "_KEGG_down.png")), plot = down, width = 12, height = 12, dpi = 300)
    }
}

# Extract KEGG p-values for each dataset
kegg_summary <- lapply(kegg_results, function(res) {
  cell_type <- as.character(res$cell_type)
  comparison <- as.character(res$comparison)

  # --- Handle up ---
  up_res <- if (!is.null(res$up) && inherits(res$up, "enrichResult")) {
    df <- as.data.frame(res$up)
    if (nrow(df) > 0) {
      df %>%
        dplyr::select(Description, p.adjust) %>%
        mutate(Regulation = "Up", CellType = cell_type, Comparison = comparison)
    } else {
      NULL
    }
  } else {
    NULL
  }

  # --- Handle down ---
  down_res <- if (!is.null(res$down) && inherits(res$down, "enrichResult")) {
    df <- as.data.frame(res$down)
    if (nrow(df) > 0) {
      df %>%
        dplyr::select(Description, p.adjust) %>%
        mutate(Regulation = "Down", CellType = cell_type, Comparison = comparison)
    } else {
      NULL
    }
  } else {
    NULL
  }

  # Combine if at least one exists
  if (!is.null(up_res) || !is.null(down_res)) {
    bind_rows(up_res, down_res)
  } else {
    NULL
  }
})

kegg_summary_df <- bind_rows(kegg_summary[!sapply(kegg_summary, is.null)])
write_csv(kegg_summary_df,"~/PTZ_ATAC_scRNA_072024/WIP/0609_run/KEGG/kegg_summary.csv")

# Convert into a matrix for heatmap
kegg_df <- bind_rows(kegg_summary, .id = "Condition") %>%
  spread(Condition, p.adjust, fill = NA)  

top_kegg <- kegg_df %>%
  pivot_longer(cols = -c(Description, Regulation, CellType, Comparison), values_to = "p.adjust") %>%
  mutate(p.adjust = as.numeric(p.adjust)) %>%
  filter(!is.na(p.adjust)) %>%
  arrange(p.adjust) %>%
  group_by(CellType, Comparison) %>%
  slice_head(n = 10)  # Keep top 10 per condition

# Barplot
output_dir <- file.path(output_dir_base, "KEGG", "Barplots")

# Loop through each unique Comparison
for (comparison in unique(top_kegg$Comparison)) {
  
  # Filter data for the specific condition
  subset_data <- top_kegg %>% filter(Comparison == comparison) %>%
    mutate(Description = gsub(" - Mus musculus \\(house mouse\\)", "", Description))  # Remove species tag

  # Generate barplot for the condition with up/down faceting
  p <- ggplot(subset_data, aes(x = reorder(Description, -p.adjust), y = -log10(p.adjust), fill = CellType)) +
    geom_bar(stat = "identity", position = "dodge") +
    coord_flip() +
    theme_minimal() +
    labs(title = paste("Top KEGG Pathways -", comparison),
         y = "-log10(p.adjust)", x = "Pathway") +
    theme(
      legend.position = "bottom",
      legend.text = element_text(size = 10),  # Make legend text readable
      axis.text.y = element_text(size = 10),  # Improve y-axis text readability
      axis.title.x = element_text(size = 14), # Increase x-axis title size
      plot.title = element_text(size = 16, face = "bold")  # Increase title size
    ) +
    guides(fill = guide_legend(nrow = 2)) +  # Arrange legend in 2 rows
    facet_wrap(~ Regulation, scales = "free_y") +  # Separate Up/Downregulated pathways
    scale_x_discrete(labels = scales::wrap_format(30))  # Wrap long pathway names

  # Save the plot with larger width
  ggsave(filename = file.path(output_dir, paste0("KEGG_", comparison, ".png")), 
         plot = p, width = 16, height = 12, dpi = 300)
}

# Loop through each unique Cell Type
for (cell in unique(top_kegg$CellType)) {
  
  # Filter data for the specific cell type
  subset_data <- top_kegg %>% filter(CellType == cell) %>%
      mutate(Description = gsub(" - Mus musculus \\(house mouse\\)", "", Description))  # Remove species tag
  
  # Generate barplot for the cell type with up/down faceting
  p <- ggplot(subset_data, aes(x = reorder(Description, -p.adjust), y = -log10(p.adjust), fill = Comparison)) +
    geom_bar(stat = "identity", position = "dodge") +
    coord_flip() +
    theme_minimal() +
    labs(title = paste("Top KEGG Pathways -", cell),
         y = "-log10(p.adjust)", x = "Pathway") +
    theme(
      legend.position = "bottom",
      legend.text = element_text(size = 10),  # Make legend text readable
      axis.text.y = element_text(size = 10),  # Make y-axis text readable
      axis.title.x = element_text(size = 14), # Increase x-axis title size
      plot.title = element_text(size = 16, face = "bold")  # Increase title size
    ) +
    guides(fill = guide_legend(nrow = 2)) +  # Arrange legend in 2 rows
    facet_wrap(~ Regulation, scales = "free_y") +  # Separate Up/Downregulated pathways
    scale_x_discrete(labels = scales::wrap_format(30))  # Wrap long pathway names

  # Save the plot with larger width
  ggsave(filename = file.path(output_dir, paste0("KEGG_", cell, ".png")), 
         plot = p, width = 16, height = 12, dpi = 300)
}

```

```{r fGSEA analysis, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Define DEG directory
deg_dir <- "~/PTZ_ATAC_scRNA_072024/WIP/0609_run/DEG/sig_csv/"
deg_files <- list.files(deg_dir, pattern = ".csv", full.names = TRUE)

# Define output base
output_dir_base <- "~/PTZ_ATAC_scRNA_072024/WIP/0609_run"

# Create output dirs
for (cat in c("fGSEA_GOMF", "fGSEA_GOBP", "fGSEA_KEGG", "fGSEA_TFT", "fGSEA_REACTOME")) {
  dir.create(file.path(output_dir_base, cat, "csv"), recursive = TRUE, showWarnings = FALSE)
  dir.create(file.path(output_dir_base, cat, "plot"), recursive = TRUE, showWarnings = FALSE)
}

# Load pathway databases
pathways_MF <- msigdbr::msigdbr(species = "Mus musculus", category = "C5", subcategory = "GO:MF")
pathways_BP <- msigdbr::msigdbr(species = "Mus musculus", category = "C5", subcategory = "GO:BP")
pathways_KG <- msigdbr::msigdbr(species = "Mus musculus", category = "C2", subcategory = "KEGG")
pathways_RE <- msigdbr::msigdbr(species = "Mus musculus", category = "C2", subcategory = "REACTOME")
# pathways_TFT <- msigdbr::msigdbr(species = "Mus musculus", category = "C3", subcategory = "TFT")

# Format into named lists
list_MF <- split(pathways_MF$gene_symbol, pathways_MF$gs_name)
list_BP <- split(pathways_BP$gene_symbol, pathways_BP$gs_name)
list_KG <- split(pathways_KG$gene_symbol, pathways_KG$gs_name)
list_RE <- split(pathways_RE$gene_symbol, pathways_RE$gs_name)
# list_TFT <- split(pathways_TFT$gene_symbol, pathways_TFT$gs_name)

# Loop through DEG files
for (file in deg_files) {
  name <- gsub(".csv", "", basename(file))
  df <- read_csv(file)

  # Validate column existence
  if (!all(c("gene", "avg_log2FC") %in% colnames(df))) {
    warning(paste("Skipping", name, "- missing gene or avg_log2FC columns"))
    next
  }

  df <- df %>%
    arrange(desc(avg_log2FC)) %>%
    dplyr::select(gene, avg_log2FC)

  if (nrow(df) < 5) {
    message(sprintf("Skipping %s: only %d genes (minimum 5 required)", name, nrow(df)))
    next
  }

  ranked <- setNames(df$avg_log2FC, df$gene)

  # Run fGSEA for each category
  results <- list(
    GOBP = fgsea::fgseaMultilevel(list_BP, ranked, minSize = 5, maxSize = 500, nPerm = 1000) %>% arrange(padj),
    GOMF = fgsea::fgseaMultilevel(list_MF, ranked, minSize = 5, maxSize = 500, nPerm = 1000) %>% arrange(padj),
    KEGG = fgsea::fgseaMultilevel(list_KG, ranked, minSize = 5, maxSize = 500, nPerm = 1000) %>% arrange(padj),
    # TFT = fgseaMultilevel(list_TFT, ranked, minSize = 5, maxSize = 500, nPerm = 1000) %>% arrange(padj),
    REACTOME =  fgsea::fgseaMultilevel(list_RE, ranked, minSize = 5, maxSize = 500, nPerm = 1000) %>% arrange(padj)
  )

  # Save CSV outputs
  for (cat in names(results)) {
    out_path <- file.path(output_dir_base, paste0("fGSEA_", cat), "csv", paste0("fGSEA_", name, ".csv"))
    data.table::fwrite(results[[cat]], file = out_path)
  }

  # Plot significant results (padj < 0.05) – top 10 only
  for (cat in names(results)) {
    top <- results[[cat]] %>%
      filter(padj < 0.05) %>%
      head(10)

    if (nrow(top) == 0) {
      message(sprintf("No significant %s pathways for %s", cat, name))
      next
    }

    # Clean up names
    top$pathway <- top$pathway %>%
      str_remove("^GOBP_|^GOMF_|^KEGG_|^REACTOME|") %>%
      str_replace_all("_", " ")
    top$pathway <- factor(top$pathway, levels = top$pathway[order(top$NES)])

    # Plot
    p <- ggplot(top, aes(x = NES, y = pathway, size = size, color = -log10(padj))) +
      geom_point() +
      scale_color_gradient(low = "#0513d8", high = "#f517d3") +
      labs(title = paste("fGSEA", cat, "Enrichment -", name),
           x = "Normalized Enrichment Score",
           y = "Pathway",
           size = "Size",
           color = "padj") +
      theme_minimal() +
      theme(axis.text.y = element_text(size = 9))

    # Save plot
    plot_file <- file.path(output_dir_base, paste0("fGSEA_", cat), "plot", paste0("fGSEA_", name, ".png"))
    ggsave(plot_file, p, width = 12, height = 10, dpi = 300)
  }
}

```

```{r SynGO}
# Set file paths
deg_dir <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/DE_gene"  # Directory with full DEG files
sig_dir <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Sig_gene" # Directory with significant DEG files

# Get file lists
deg_files <- list.files(deg_dir, pattern = "DE_results_.*\\.csv", full.names = TRUE)
sig_files <- list.files(sig_dir, pattern = "Significant_genes_.*\\.csv", full.names = TRUE)

# Create output directory
output_dir <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/SynGO_Results"
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)

# Load SynGO data
syngo_genes <- read_excel("~/PTZ_ATAC_scRNA_072024/File/SynGO/SynGO_bulk_download_release_20231201/syngo_genes.xlsx")
syngo_annotations <- read_excel("~/PTZ_ATAC_scRNA_072024/File/SynGO/SynGO_bulk_download_release_20231201/syngo_annotations.xlsx")
syngo_ontologies <- read_excel("~/PTZ_ATAC_scRNA_072024/File/SynGO/SynGO_bulk_download_release_20231201/syngo_ontologies.xlsx")

# Process ontology data - adjust column names based on actual data
ontology_data <- syngo_ontologies %>%
  # Rename columns (adjust based on your actual column names)
  rename(
    go_id = id,  # Adjust these column names based on your actual data
    go_name = name,
    go_namespace = domain
  ) %>%
  dplyr::select(go_id, go_name, go_namespace) %>%
  distinct()

# Create a data frame to store all results
all_results_summary <- data.frame(
  File = character(),
  Cell_Type = character(),
  Comparison = character(),
  Total_DEGs = integer(),
  Total_Significant = integer(),
  Genes_In_SynGO = integer(),
  Significant_Terms = integer(),
  Top_Terms = character(),
  stringsAsFactors = FALSE
)

# Match sig_files with their corresponding deg_files
for(i in seq_along(sig_files)) {
  tryCatch({
    # Extract file info from sig file
    sig_file_name <- basename(sig_files[i])
    sig_parts <- strsplit(gsub("Significant_genes_|.csv", "", sig_file_name), "_")[[1]]
    cell_type <- sig_parts[1]
    comparison_name <- paste(sig_parts[-1], collapse = "_")
    
    # Find matching DEG file
    matching_deg_pattern <- paste0("DE_results_", cell_type, "_", comparison_name, ".csv")
    matching_deg_file <- deg_files[grep(matching_deg_pattern, deg_files)]
    
    if(length(matching_deg_file) == 0) {
      message(sprintf("No matching DEG file found for %s", sig_file_name))
      next
    }
    
    message(sprintf("\nProcessing %s with background from %s", sig_file_name, basename(matching_deg_file)))
    
    # Read DEG file (background genes) and sig file (genes of interest)
    deg_data <- read_csv(matching_deg_file)
    sig_data <- read_csv(sig_files[i])
    
    # Check if gene column exists in both files
    if(!"gene" %in% colnames(deg_data) || !"gene" %in% colnames(sig_data)) {
      message(sprintf("Warning: 'gene' column missing in one of the files"))
      next
    }
    
    # Extract gene lists
    background_genes <- deg_data$gene
    background_genes <- background_genes[!is.na(background_genes) & background_genes != ""]
    
    significant_genes <- sig_data$gene
    significant_genes <- significant_genes[!is.na(significant_genes) & significant_genes != ""]
    
    if(length(background_genes) == 0 || length(significant_genes) == 0) {
      message(sprintf("Warning: Empty gene list in one of the files"))
      next
    }
    
    message(sprintf("Background: %d genes, Significant: %d genes", 
                   length(background_genes), length(significant_genes)))
    
    # Check which genes are in SynGO database
    # Adjust column names as needed based on your SynGO data
    syngo_gene_symbols <- syngo_genes$hgnc_symbol  # Adjust column name if needed
    
    # Find genes present in SynGO
    background_in_syngo <- background_genes[toupper(background_genes) %in% toupper(syngo_gene_symbols)]
    significant_in_syngo <- significant_genes[toupper(significant_genes) %in% toupper(syngo_gene_symbols)]
    
    message(sprintf("Background genes in SynGO: %d (%.1f%%)", 
                   length(background_in_syngo), 
                   100 * length(background_in_syngo) / length(background_genes)))
    
    message(sprintf("Significant genes in SynGO: %d (%.1f%%)", 
                   length(significant_in_syngo), 
                   100 * length(significant_in_syngo) / length(significant_genes)))
    
    # Skip if no significant genes in SynGO
    if(length(significant_in_syngo) == 0) {
      message("No significant genes found in SynGO database, skipping.")
      
      all_results_summary <- rbind(all_results_summary, data.frame(
        File = sig_file_name,
        Cell_Type = cell_type,
        Comparison = comparison_name,
        Total_DEGs = length(background_genes),
        Total_Significant = length(significant_genes),
        Genes_In_SynGO = 0,
        Significant_Terms = 0,
        Top_Terms = "None",
        stringsAsFactors = FALSE
      ))
      
      next
    }
    
    # Get annotations for our significant genes
    sig_gene_annotations <- 
      syngo_annotations %>%
      left_join(syngo_genes %>% 
                  dplyr::select(hgnc_id), by = "hgnc_id") %>%
      filter(toupper(hgnc_symbol) %in% toupper(significant_in_syngo)) %>%
      left_join(ontology_data %>% 
                  dplyr::select(go_id, go_namespace), by = "go_id")
    
    # Skip if no annotations found
    if(nrow(sig_gene_annotations) == 0) {
      message("No SynGO annotations found for significant genes, skipping.")
      
      all_results_summary <- rbind(all_results_summary, data.frame(
        File = sig_file_name,
        Cell_Type = cell_type,
        Comparison = comparison_name,
        Total_DEGs = length(background_genes),
        Total_Significant = length(significant_genes),
        Genes_In_SynGO = length(significant_in_syngo),
        Significant_Terms = 0,
        Top_Terms = "None",
        stringsAsFactors = FALSE
      ))
      
      next
    }
    
    # Count significant genes per GO term
    term_counts <- sig_gene_annotations %>%
      group_by(go_id) %>%
      # Summarize to ensure one row per GO ID
      summarize(
        go_name = first(go_name),
        go_namespace = first(go_namespace),
        Gene_Count = n_distinct(hgnc_symbol),
        Genes = paste(sort(unique(hgnc_symbol)), collapse = ", "),
        .groups = 'drop'
      )
    
    # Count background genes per GO term
    message("Counting background genes per GO term...")
    background_counts <- data.frame(go_id = character(), Background_Count = integer(), stringsAsFactors = FALSE)
    
    # Process each GO term from our significant genes
    unique_go_terms <- unique(term_counts$go_id)
    for(term in unique_go_terms) {
      # Find background genes with this annotation
      bg_genes <- syngo_annotations %>%
        filter(go_id == term) %>%
        left_join(syngo_genes %>% 
                  dplyr::select(hgnc_id), by = "hgnc_id") %>%
        filter(toupper(hgnc_symbol) %in% toupper(background_in_syngo)) %>%
        pull(hgnc_symbol) %>%
        unique()
      
      # Add to background counts
      background_counts <- rbind(background_counts, 
                                data.frame(go_id = term, 
                                           Background_Count = length(bg_genes)))
    }
    
    # Check for entries with zero background count
    zero_bg <- background_counts %>% filter(Background_Count == 0)
    if(nrow(zero_bg) > 0) {
      message(sprintf("Warning: %d GO terms have zero background count", nrow(zero_bg)))
      
      # Fix zero background counts (they should at least include the significant genes)
      background_counts_fixed <- term_counts %>%
        left_join(background_counts, by = "go_id") %>%
        mutate(
          Background_Count = pmax(Gene_Count, Background_Count)
        ) %>%
        dplyr::select(go_id, Background_Count)
      
      background_counts <- background_counts_fixed
    }
    
    # Merge term counts with background counts
    enrichment_results <- term_counts %>%
      left_join(background_counts, by = "go_id")
    
    # Double-check for duplicate GO terms one more time
    if(any(duplicated(enrichment_results$go_id))) {
      message("Warning: Found duplicate GO terms after join, fixing...")
      enrichment_results <- enrichment_results %>%
        group_by(go_id) %>%
        slice_head(n=1) %>%
        ungroup()
    }
    
    # Calculate enrichment statistics
    total_query_genes <- length(significant_in_syngo)
    total_background_genes <- length(background_in_syngo)
    
    enrichment_results <- enrichment_results %>%
      mutate(
        GeneRatio = paste0(Gene_Count, "/", total_query_genes),
        BgRatio = paste0(Background_Count, "/", total_background_genes),
        Fold_Enrichment = case_when(
          Background_Count == 0 ~ NA_real_,
          TRUE ~ (Gene_Count / total_query_genes) / (Background_Count / total_background_genes)
        )
      )
    
    # Calculate p-values using Fisher's exact test
    message("Calculating Fisher's exact test p-values...")
    enrichment_results$P_value <- sapply(1:nrow(enrichment_results), function(i) {
      # Create a proper 2x2 contingency table
      a <- enrichment_results$Gene_Count[i]  # Significant genes with this GO term
      b <- enrichment_results$Background_Count[i] - a  # Background genes (not significant) with GO term
      b <- max(0, b)  # Ensure non-negative
      
      c <- total_query_genes - a  # Significant genes without this GO term
      d <- total_background_genes - a - b - c  # Other background genes without the term
      d <- max(0, d)  # Ensure non-negative
      
      # Use Fisher's exact test
      result <- fisher.test(matrix(c(a, b, c, d), nrow = 2), alternative = "greater")
      return(result$p.value)
    })
    
    # Apply multiple testing correction
    enrichment_results$Adjusted_P_value <- p.adjust(enrichment_results$P_value, method = "BH")
    
    # Filter for significant results
    significant_results <- enrichment_results %>%
      filter(P_value < 0.05)
    
    # Get significant terms count
    sig_terms_count <- nrow(significant_results)
    
    # Get top terms
    top_terms <- if(sig_terms_count > 0) {
      paste(head(significant_results$go_name, 3), collapse = ", ")
    } else {
      "None"
    }
    
    message(sprintf("Found %d significant GO terms", sig_terms_count))
    
    # Add to summary
    all_results_summary <- rbind(all_results_summary, data.frame(
      File = sig_file_name,
      Cell_Type = cell_type,
      Comparison = comparison_name,
      Total_DEGs = length(background_genes),
      Total_Significant = length(significant_genes),
      Genes_In_SynGO = length(significant_in_syngo),
      Significant_Terms = sig_terms_count,
      Top_Terms = top_terms,
      stringsAsFactors = FALSE
    ))
    
    # Create output file prefix
    output_csv_prefix <- file.path(output_dir, 'csv', paste0("SynGO_", cell_type, "_", comparison_name))
    output_plot_prefix <- file.path(output_dir, 'DotPlots', paste0("SynGO_", cell_type, "_", comparison_name))
    
    # Save results
    write.csv(enrichment_results, paste0(output_csv_prefix, "_all_results.csv"), row.names = FALSE)
    
    if(sig_terms_count > 0) {
      write.csv(significant_results, paste0(output_csv_prefix, "_significant_results.csv"), row.names = FALSE)
      
      # Create plots
      message("Generating plots...")
      
      # Get top 20 results for plotting (or all if fewer)
      plot_data <- significant_results %>%
        arrange(Adjusted_P_value) %>%
        head(min(20, nrow(significant_results)))
      
      plot_title <- paste(cell_type, comparison_name)
      
      # Create dotplot
      p1 <- ggplot(plot_data, 
                  aes(x = -log10(P_value), y = reorder(go_name, -log10(P_value)))) +
        geom_point(aes(size = Gene_Count, color = Fold_Enrichment)) +
        scale_color_gradient(low = "red", high = "blue", trans = "log10") +
        labs(
          title = paste(plot_title, "- Dotplot"),
          x = "-log10(P-value)",
          y = "GO Term",
          size = "Gene Count",
          color = "Fold Enrichment"
        ) +
        theme_minimal() +
        theme(
          axis.text.y = element_text(size = 9),
          plot.title = element_text(size = 12, face = "bold")
        ) +
        scale_y_discrete(labels = label_wrap(40)) 
      
      ggsave(paste0(output_plot_prefix, "_dotplot.png"), p1, width = 15, height = 8, dpi = 300)
      
      # # Create barplot
      # p2 <- ggplot(plot_data,
      #             aes(x = reorder(go_name, P_value), y = P_value)) +
      #   geom_bar(stat = "identity", fill = "steelblue") +
      #   coord_flip() +
      #   labs(
      #     title = paste(plot_title, "- Barplot"),
      #     x = "GO Term",
      #     y = "P-value"
      #   ) +
      #   theme_minimal() +
      #   theme(
      #     axis.text.y = element_text(size = 9),
      #     plot.title = element_text(size = 12, face = "bold")
      #   ) +
      #   scale_y_discrete(labels = label_wrap(40))
      # 
      # ggsave(paste0(output_plot_prefix, "_barplot.png"), p2, width = 10, height = 8, dpi = 300)

      # Create barplot by categories if namespace column exists
      # if("go_namespace" %in% colnames(plot_data)) {
      #   p3 <- ggplot(plot_data,
      #               aes(x = reorder(go_name, P_value),
      #                   y = P_value,
      #                   fill = go_namespace)) +
      #     geom_bar(stat = "identity") +
      #     coord_flip() +
      #     scale_fill_brewer(palette = "Set1") +
      #     labs(
      #       title = paste(plot_title, "- By Category"),
      #       x = "GO Term",
      #       y = "P_value",
      #       fill = "Category"
      #     ) +
      #     theme_minimal() +
      #     theme(
      #     axis.text.y = element_text(size = 9),
      #     plot.title = element_text(size = 12, face = "bold")
      #   ) +
      #   scale_y_discrete(labels = label_wrap(40))
      # 
      #   ggsave(paste0(output_plot_prefix, "_by_category.png"), p3, width = 10, height = 8, dpi = 300)
      # }
    }
    
    message(sprintf("Completed processing %s", sig_file_name))
  }, error = function(e) {
    message(sprintf("Error processing %s: %s", sig_files[i], e$message))
  })
}

# Save summary results
write.csv(all_results_summary, file.path(output_dir, 'summary', 'csv', "SynGO_enrichment_summary.csv"), row.names = FALSE)

# Create summary plots if we have results
if(nrow(all_results_summary) > 0 && sum(all_results_summary$Significant_Terms) > 0) {
  # Filter for entries with significant terms
  summary_with_sig <- all_results_summary %>%
    filter(Significant_Terms > 0)
  
  if(nrow(summary_with_sig) > 0) {
    # Create summary plot directory
    summary_plot_dir <- file.path(output_dir, 'summary', "plots")
    dir.create(summary_plot_dir, showWarnings = FALSE, recursive = TRUE)
    
    # Create plot by comparison
    for(comp in unique(summary_with_sig$Comparison)) {
      comp_data <- summary_with_sig %>% filter(Comparison == comp)
      
      if(nrow(comp_data) > 0) {
        p <- ggplot(comp_data, aes(x = reorder(Cell_Type, Significant_Terms), y = Significant_Terms)) +
          geom_bar(stat = "identity", fill = "steelblue") +
          geom_text(aes(label = Significant_Terms), hjust = -0.2) +  # Add count labels
          coord_flip() +
          labs(
            title = paste("SynGO Enrichment -", comp),
            subtitle = paste0("Total cell types: ", nrow(comp_data)),
            x = "Cell Type",
            y = "Number of Significant Terms"
          ) +
          theme_minimal()
        
        ggsave(file.path(summary_plot_dir, paste0("SynGO_summary_", comp, ".png")), 
               p, width = 10, height = max(6, nrow(comp_data) * 0.4), dpi = 300)
      }
    }
    
    # Create plot by cell type
    for(cell in unique(summary_with_sig$Cell_Type)) {
      cell_data <- summary_with_sig %>% filter(Cell_Type == cell)
      
      if(nrow(cell_data) > 0) {
        p <- ggplot(cell_data, aes(x = reorder(Comparison, Significant_Terms), y = Significant_Terms)) +
          geom_bar(stat = "identity", fill = "steelblue") +
          geom_text(aes(label = Significant_Terms), hjust = -0.2) +  # Add count labels
          coord_flip() +
          labs(
            title = paste("SynGO Enrichment -", cell),
            subtitle = paste0("Total comparisons: ", nrow(cell_data)),
            x = "Comparison",
            y = "Number of Significant Terms"
          ) +
          theme_minimal()
        
        ggsave(file.path(summary_plot_dir, paste0("SynGO_summary_", cell, ".png")), 
               p, width = 10, height = max(6, nrow(cell_data) * 0.4), dpi = 300)
      }
    }
  }
}

```

```{r ATAC Motif analysis setup, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# this is org annotation file
mm10 <-import("/igm/apps/10X_chromium/refdata-cellranger-arc-mm10-2020-A-2.0.0/genes/genes.gtf.gz")
merged_atac
merged_atac_processed
DefaultAssay(combined_merged) <- "ATAC"

# Check  sequence levels contain meaningful peaks or annotations
seqinfo(Annotation(combined_merged))
seqlevels(Annotation(combined_merged))  
table(seqnames(Annotation(combined_merged)))

# seqlevelsStyle(BSgenome.Mmusculus.UCSC.mm10) <- seqlevelsStyle(Annotation(combined_merged))

# Check for mismatches - most likely non-standard chr will pop up.
# setdiff(seqlevels(Annotation(combined_merged)), seqlevels(BSgenome.Mmusculus.UCSC.mm10))

# keep only standard chromosome, Filter Non-Matching Seqlevels
Annotation(combined_merged) <- keepStandardChromosomes(Annotation(combined_merged), pruning.mode = "coarse")

# Update the seqlengths in your annotations
seq_lengths <- seqlengths(BSgenome.Mmusculus.UCSC.mm10)
seqlengths(Annotation(combined_merged)) <- seq_lengths[names(seqlengths(Annotation(combined_merged)))]

# Check for mismatches
# setdiff(seqlevels(Annotation(combined_merged)), seqlevels(BSgenome.Mmusculus.UCSC.mm10))

# Check  sequence levels contain meaningful peaks or annotations
seqinfo(Annotation(combined_merged))
seqlevels(Annotation(combined_merged))  
table(seqnames(Annotation(combined_merged)))

# since I imported Grange object, and it is missing row names (it is not inherent)
# Add identifiers as metadata 
mcols(Annotation(combined_merged))$gene_id <- make.unique(as.character(mcols(Annotation(combined_merged))$gene_id))
names(Annotation(combined_merged)) <- mcols(Annotation(combined_merged))$gene_id

# Verify the result
head(mcols(Annotation(combined_merged))$gene_id)
head(names(Annotation(combined_merged)))

# this is extra if needed a separate obj for ID.
# # Extract gene IDs as a vector
# gene_ids <- make.unique(as.character(mcols(Annotation(combined_merged))$gene_id))
# # Convert GRanges to data.frame with row names
# annotation_df <- as.data.frame(Annotation(combined_merged))
# rownames(annotation_df) <- gene_ids
# # Use gene_ids for other operations
# head(gene_ids)

# check GC content
# Check GC content summary
summary(combined_merged@assays$ATAC@meta.features$GC.percent)

# calculate GC content, if missing.
combined_merged <- RegionStats(
  object = combined_merged,
  genome = BSgenome.Mmusculus.UCSC.mm10,
  assay = "ATAC", 
  verbose = T
)

# work on GC content
# Identify regions with missing GC content
missing_gc <- rownames(combined_merged@assays$ATAC@meta.features)[
  is.na(combined_merged@assays$ATAC@meta.features$GC.percent)
]

# Check seqlevels of regions with missing GC content
missing_seqnames <- sapply(strsplit(missing_gc, "-"), `[`, 1)
table(missing_seqnames)

# to fix. NA GC are in non-standard chr which I thought I cleaned.
# my object filtered out non-standard chromosomes. but  it is still showing up (it is the couase of NA value..)
# Extract seqnames from rownames in meta.features
all_seqnames <- sapply(strsplit(rownames(combined_merged@assays$ATAC@meta.features), "-"), `[`, 1)

# Identify regions on standard chromosomes
valid_regions <- which(all_seqnames %in% seqlevels(Annotation(combined_merged)))

# Subset the ATAC assay by valid regions to get ride of non-standard data (which have NA GC content value)
combined_merged@assays$ATAC <- subset(
  combined_merged@assays$ATAC,
  features = rownames(combined_merged@assays$ATAC@meta.features)[valid_regions]
)

# now we should have no NA value.
summary(combined_merged@assays$ATAC@meta.features$GC.percent)
```

```{r Motif analysis, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Load motif database for mouse
pwm <- getMatrixSet(
  x = JASPAR2020,
  opts = list(collection = "CORE", tax_group = "vertebrates", species = 10090) # 10090 is the NCBI Taxonomy ID for mouse
)

length(pwm)  # Number of motifs
names(pwm)   # Names of the motifs

# add motif
combined_merged <- AddMotifs(
  object = combined_merged,
  genome = BSgenome.Mmusculus.UCSC.mm10,  # Use the filtered genome
  pfm = pwm
)

# Check object
combined_merged@assays$ATAC@motifs
summary(combined_merged@assays$ATAC@meta.features$GC.percent)
# Get unique column names without ".1" duplicates
meta.feature <- combined_merged@assays$ATAC@meta.features

# Remove columns that are duplicates (keeping the first occurrence)
meta.feature <- meta.feature[, !duplicated(colnames(meta.feature))]

# Also, explicitly remove columns that end in ".1"
meta.feature <- meta.feature[, !grepl("\\.1$", colnames(meta.feature))]

# Assign the cleaned metadata back
combined_merged@assays$ATAC@meta.features <- meta.feature

# # Rename the column
# colnames(combined_merged@assays$ATAC@meta.features)[
#   colnames(combined_merged@assays$ATAC@meta.features) == "gc.percent"
# ] <- "GC.percent"
# 
# meta_features <- combined_merged@assays$ATAC@meta.features
# # Remove duplicate columns by keeping only the first instance
# meta_features <- meta_features[, !duplicated(colnames(meta_features))]
# combined_merged@assays$ATAC@meta.features <- meta_features

summary(combined_merged@assays$ATAC@meta.features$GC.percent)
head(combined_merged[["ATAC"]]@motifs)
dim(combined_merged[['ATAC']][[]])
head(combined_merged[['ATAC']][[]])
table(seqnames(Annotation(combined_merged)))
seqlevels(Annotation(combined_merged))
seqinfo(Annotation(combined_merged))
```

```{r Save point - Modif added, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
saveRDS(combined_merged, "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/RDS_mid/combined_merged_atac_work.rds")
```

```{r Motif enrichment analysis setup, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Verify the results
summary(combined_merged@assays$ATAC@meta.features$GC.percent)

# Get unique cell types
cell_types <- unique(combined_merged$Cell_type_by_multimodal)

# Define group comparisons
comparisons_to_analyze <- list(
  "PTZvsSAL_24hr" = list(name = "PTZvsSAL_24hr", group1 = "PTZ_24hr", group2 = "SAL_24hr"),
  "PTZvsSAL_1hr" = list(name = "PTZvsSAL_1hr", group1 = "PTZ_1hr", group2 = "SAL_1hr"),
  "24hrvs1hr_PTZ" = list(name = "24hrvs1hr_PTZ", group1 = "PTZ_24hr", group2 = "PTZ_1hr"),
  "24hrvs1hr_SAL" = list(name = "24hrvs1hr_SAL", group1 = "SAL_24hr", group2 = "SAL_1hr")
)

# Initialize summary statistics
summary_stats <- data.frame()

# output path
output_dir_base <-"~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/"

dir.create(file.path(output_dir_base, "DA_ATAC"))
dir.create(file.path(output_dir_base, "Sig_ATAC"))
dir.create(file.path(output_dir_base, "Motif_Enrichment"), showWarnings = FALSE)
```

```{r Motif enrichment analysis, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
for (cell_type in cell_types) {
  for (comp in comparisons_to_analyze) {
    tryCatch({
      message(sprintf("\nAnalyzing %s - %s", cell_type, comp$name))
      
      # Subset data for the current cell type and comparison
      cell_type_data <- subset(
        combined_merged,
        subset = Cell_type_by_multimodal == cell_type & 
          sample %in% c(comp$group1, comp$group2)
      )
      
      DefaultAssay(cell_type_data) <- "ATAC"
      Idents(cell_type_data) <- "sample"
      
      # Get cell counts for each group
      cell_count_group1 <- sum(Idents(cell_type_data) == comp$group1)
      cell_count_group2 <- sum(Idents(cell_type_data) == comp$group2)
      
      message(sprintf("Cell counts - %s: %d, %s: %d",
                      comp$group1, cell_count_group1,
                      comp$group2, cell_count_group2))
      
      # Check minimum cell threshold (avoid low sample size)
      if (cell_count_group1 >= 3 && cell_count_group2 >= 3) {
        # Perform DA peak analysis
        da_results <- FindMarkers(
          object = cell_type_data,
          assay = "ATAC",
          ident.1 = comp$group1,
          ident.2 = comp$group2,
          min.pct = 0.05,
          test.use = "LR",
          latent.vars = "nCount_ATAC"
        )
        
        # Add metadata
        da_results$gene <- rownames(da_results)
        da_results$cell_type <- cell_type
        da_results$comparison <- comp$name
        
        # Filter significant DA peaks
        sig_atac_peaks <- da_results$gene[da_results$p_val_adj < 0.05 & abs(da_results$avg_log2FC) > 0.2]
        
        # Save DA results
        safe_comp_name <- gsub("[:]", "_", comp$name)
        csv_filename <- sprintf("DA_results_%s_%s.csv", cell_type, safe_comp_name)
        write.csv(
          da_results,
          file = file.path(output_dir_base, "DA_ATAC", csv_filename),
          row.names = FALSE
        )
        
        csv_filename2 <- sprintf("Sig_results_%s_%s.csv", cell_type, safe_comp_name)
        write.csv(
          sig_atac_peaks,
          file = file.path(output_dir_base, "Sig_ATAC", csv_filename2),
          row.names = FALSE
        )
        
        message(sprintf("Analysis complete. Found %d significant DA peaks", length(sig_atac_peaks)))
        
        # **Perform Motif Analysis on Significant DA Peaks**
        if (length(sig_atac_peaks) > 0) {
          # Split DA peaks into Upregulated & Downregulated
          up_peaks <- da_results$gene[da_results$p_val_adj < 0.05 & da_results$avg_log2FC > 0.2]
          down_peaks <- da_results$gene[da_results$p_val_adj < 0.05 & da_results$avg_log2FC < -0.2]
          
          # **Motif analysis for upregulated DA peaks**
          if (length(up_peaks) > 10) {
            motif_results_up <- FindMotifs(
              object = cell_type_data,
              assay = "ATAC",
              features = up_peaks,
              background = 500
            )
            motif_results_up$direction <- "up"
            write.csv(
              motif_results_up,
              file = file.path(output_dir_base, "Motif_Enrichment", 
                               sprintf("Motif_results_%s_%s_UP.csv", cell_type, safe_comp_name)),
              row.names = FALSE
            )
          } else {
            message(sprintf("Skipping upregulated motif analysis: too few DA peaks (%d found)", length(up_peaks)))
          }
          
          # **Motif analysis for downregulated DA peaks**
          if (length(down_peaks) > 10) {
            motif_results_down <- FindMotifs(
              object = cell_type_data,
              assay = "ATAC",
              features = down_peaks,
              background = 500
            )
            motif_results_down$direction <- "down"
            write.csv(
              motif_results_down,
              file = file.path(output_dir_base, "Motif_Enrichment", 
                               sprintf("Motif_results_%s_%s_DOWN.csv", cell_type, safe_comp_name)),
              row.names = FALSE
            )
          } else {
            message(sprintf("Skipping downregulated motif analysis: too few DA peaks (%d found)", length(down_peaks)))
          }
          
        } else {
          message("Skipping motif analysis: No significant DA peaks found.")
        }
        
      } else {
        message("Skipping analysis: insufficient cells (minimum 3 required per group)")
      }
      
    }, error = function(e) {
      message(sprintf("Error in analysis: %s", e$message))
    })
  }
}
```

```{r DAG volcano plot, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# file read
csv_files <- list.files(file.path(output_dir_base, "DA_ATAC"), pattern = "DA_results_.+\\.csv$", full.names = TRUE)

# loop
for (csv_file in csv_files) {
  # Extract cell type and comparison name from file name
  file_name <- basename(csv_file)
  parts <- strsplit(gsub("DA_results_|.csv", "", file_name), "_")[[1]]
  cell_type <- parts[1]
  comparison_name <- paste(parts[-1], collapse = "_")
  
  # Replace colons with underscores in comparison name
  safe_comparison_name <- gsub("[:]", "_", comparison_name)
  print(paste("Creating volcano plot for", cell_type, "-", comparison_name))
  
  # Read CSV file
  da_results <- read.csv(csv_file)
  
  # Create volcano plot
  volcano_plot <- EnhancedVolcano(da_results,
                                  lab = da_results$gene,
                                  x = 'avg_log2FC',
                                  y = 'p_val_adj',
                                  title = paste('Volcano plot -', cell_type),
                                  subtitle = safe_comparison_name,
                                  pCutoff = 0.05,
                                  FCcutoff = 0.2,
                                  pointSize = 1.0,
                                  labSize = 3.0
  )
  
  # Save volcano plot with safe filename
  plot_file_name <- paste0("Volcano_plot_", cell_type, "_", safe_comparison_name, ".png")
  ggsave(file.path(output_dir_base, "Plots","VolcanoPlots_ATAC", plot_file_name), volcano_plot, width = 12, height = 10)
  print(paste("Saved volcano plot:", plot_file_name))
}
```

```{r CoveragePlot}
# Setup paths
output_dir_base <- "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/"

# Read list of significant gene files and DA peak files
sig_gene_files <- list.files(file.path(output_dir_base, "Sig_gene"), 
                             pattern = "Significant_genes_.+\\.csv$", 
                             full.names = TRUE)

sig_peak_files <- list.files(file.path(output_dir_base, "Sig_ATAC"), 
                             pattern = "Sig_results_.+\\.csv$", 
                             full.names = TRUE)

# Create output directory for plots
dir.create(file.path(output_dir_base, "Plots", "CoveragePlots"), 
           recursive = TRUE, showWarnings = FALSE)

# Define comparison groups for reference
comparisons_to_analyze <- list(
  "PTZvsSAL_24hr" = list(name = "PTZvsSAL_24hr", group1 = "PTZ_24hr", group2 = "SAL_24hr"),
  "PTZvsSAL_1hr" = list(name = "PTZvsSAL_1hr", group1 = "PTZ_1hr", group2 = "SAL_1hr"),
  "24hrvs1hr_PTZ" = list(name = "24hrvs1hr_PTZ", group1 = "PTZ_24hr", group2 = "PTZ_1hr"),
  "24hrvs1hr_SAL" = list(name = "24hrvs1hr_SAL", group1 = "SAL_24hr", group2 = "SAL_1hr")
)
# Loop through significant gene files and process each one
for (gene_file in sig_gene_files) {
  tryCatch({
    # Extract cell type and comparison from filename
    file_name <- basename(gene_file)
    parts <- strsplit(gsub("Significant_genes_|.csv", "", file_name), "_")[[1]]
    cell_type <- parts[1]
    comparison_name <- paste(parts[-1], collapse = "_")
    
    # Get the corresponding groups from our reference list
    comp_info <- comparisons_to_analyze[[comparison_name]]
    
    if (is.null(comp_info)) {
      message(sprintf("Skipping %s: Unknown comparison name", comparison_name))
      next
    }
    
    # Find the matching peak file for this cell type and comparison
    peak_file_pattern <- paste0("Sig_results_", cell_type, "_", comparison_name, ".csv")
    peak_file <- sig_peak_files[grepl(peak_file_pattern, sig_peak_files)]
    
    if (length(peak_file) == 0) {
      message(sprintf("No matching peak file found for %s - %s", cell_type, comparison_name))
      next
    }
    
    # Read significant DEGs
    de_genes <- read.csv(gene_file)
    
    # Filter for highly significant genes if needed
    filtered_genes <- de_genes %>% 
      dplyr::filter(p_val_adj < 0.000001) %>%
      arrange(desc(abs(avg_log2FC)))
    
    # If no genes pass the filter, try a more lenient threshold
    if (nrow(filtered_genes) == 0) {
      filtered_genes <- de_genes %>% 
        head(10)  # Just take top 10 genes if no genes pass strict filter
    }
    
    # Read significant peaks
    sig_peaks <- read.csv(peak_file)
    
    # Skip if either genes or peaks list is empty
    if (nrow(filtered_genes) == 0 || length(sig_peaks) == 0) {
      message(sprintf("Skipping %s - %s: No significant genes or peaks", cell_type, comparison_name))
      next
    }
    
    # Create a proper subset for this cell type and comparison
    message(sprintf("Creating subset for %s - %s", cell_type, comparison_name))
    cell_type_data <- subset(
      combined_merged,
      subset = Cell_type_by_multimodal == cell_type & 
        sample %in% c(comp_info$group1, comp_info$group2)
    )
    
    # Set assay and identities
    DefaultAssay(cell_type_data) <- "ATAC"
    Idents(cell_type_data) <- "sample"
    
    # Generate links between peaks and genes
    message("Generating peak-gene links...")
    cell_type_data <- LinkPeaks(
      object = cell_type_data,
      peak.assay = "ATAC",
      expression.assay = "RNA",
      min.distance = 50000,
      genes.use = filtered_genes$gene
    )
    
    # Extract peak-gene links and sort by significance
    peak_gene_links <- Links(cell_type_data) %>%
      as.data.frame() %>%
      as_tibble() %>%
      arrange(pvalue)
    
    # If we have any links, generate coverage plots
    if (nrow(peak_gene_links) > 0) {
      # Limit to top 10 or fewer links to avoid generating too many plots
      plot_count <- min(10, nrow(peak_gene_links))
      
      message(sprintf("Generating %d coverage plots...", plot_count))
      
      for (i in 1:plot_count) {
        gene_name <- peak_gene_links$gene[i]
        
        plot <- CoveragePlot(
          object = cell_type_data,
          region = gene_name,
          features = gene_name,
          idents = c(comp_info$group1, comp_info$group2),
          peaks.group.by = "sample",
          expression.assay = "RNA",
          extend.upstream = 100000,
          extend.downstream = 100000
        )
        
        # Create filename and save plot
        plot_filename <- paste0(
          "CoveragePlot_", gene_name, "_", 
          comp_info$group1, "_", comp_info$group2, "_", cell_type, ".png"
        )
        
        ggsave(
          filename = file.path(output_dir_base, "Plots", "CoveragePlots", plot_filename),
          plot = plot,
          width = 16,
          height = 8,
          dpi = 300
        )
        
        message(sprintf("Saved plot for %s", gene_name))
      }
    } else {
      message("No peak-gene links found")
    }
    
  }, error = function(e) {
    message(sprintf("Error processing %s: %s", file_name, e$message))
  })
}
```

```{r Pseudotime prep subset object, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
hp_subset <- subset(combined_merged, subset = Cell_type_by_multimodal %in% c("ExcitatoryNeuronsCA1", "ExcitatoryNeuronsCA3", "ExcitatoryNeuronsMatureDG", "ExcitatoryNeuronsImmatureDG"))
umap <- Embeddings(hp_subset, "Multi_umap")
celltype <- hp_subset$Cell_type_by_multimodal

ca_subset <- subset(combined_merged, subset = Cell_type_by_multimodal %in% c("ExcitatoryNeuronsCA1", "ExcitatoryNeuronsCA3"))
umap_ca <- Embeddings(ca_subset, "Multi_umap")
celltype_ca <- ca_subset$Cell_type_by_multimodal

dg_subset <- subset(combined_merged, subset = Cell_type_by_multimodal %in% c("ExcitatoryNeuronsMatureDG", "ExcitatoryNeuronsImmatureDG"))
umap_dg <- Embeddings(dg_subset, "Multi_umap")
celltype_dg <- dg_subset$Cell_type_by_multimodal

```

```{r Pseudotime Sligshot, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
lineages <- slingshot(umap, clusterLabels = celltype, reducedDim = "UMAP")
lineages_ca <- slingshot(umap_ca, clusterLabels = celltype_ca, reducedDim = "UMAP")
lineages_dg <- slingshot(umap_dg, clusterLabels = celltype_dg, reducedDim = "UMAP")

# Convert the UMAP embeddings into a data frame for plotting
umap_df <- as.data.frame(umap)
colnames(umap_df) <- c("Multiumap_1", "Multiumap_2")
umap_df$cell_type <- celltype
umap_df <- cbind(umap_df, hp_subset@meta.data)

umap_ca_df <- as.data.frame(umap_ca)
colnames(umap_ca_df) <- c("Multiumap_1", "Multiumap_2")
umap_ca_df$cell_type <- celltype_ca
umap_ca_df <- cbind(umap_ca_df, ca_subset@meta.data)

umap_dg_df <- as.data.frame(umap_dg)
colnames(umap_dg_df) <- c("Multiumap_1", "Multiumap_2")
umap_dg_df$cell_type <- celltype_dg
umap_dg_df <- cbind(umap_dg_df, dg_subset@meta.data)

# Extract pseudotime from the first lineage (if multiple lineages exist, you can choose the one of interest)
umap_df$pseudotime <-  lineages@assays@data@listData[["pseudotime"]]
umap_ca_df$pseudotime <-  lineages_ca@assays@data@listData[["pseudotime"]]
umap_dg_df$pseudotime <-  lineages_dg@assays@data@listData[["pseudotime"]]

# Plot UMAP with pseudotime as color
pseudo <- ggplot(umap_df, aes(x = Multiumap_1, y = Multiumap_2, color = pseudotime)) +
  geom_point(size = 1) +
  scale_color_viridis_c(na.value = "grey50") +
  labs(title = "Pseudotime Trajectory (Slingshot)",
       color = "Pseudotime") +
  theme_minimal()

condition <-ggplot(umap_df, aes(x = Multiumap_1, y = Multiumap_2, color = pseudotime)) +
    geom_point(size = 1) +
    scale_color_viridis_c(na.value = "grey50") +
    facet_wrap(~ sample) +  # adjust "condition" as needed
    labs(title = "Pseudotime by Condition",
         x = "UMAP 1", y = "UMAP 2") +
    theme_minimal()

pseudo_ca <- ggplot(umap_ca_df, aes(x = Multiumap_1, y = Multiumap_2, color = pseudotime)) +
  geom_point(size = 1) +
  scale_color_viridis_c(na.value = "grey50") +
  labs(title = "Pseudotime Trajectory (Slingshot)",
       color = "Pseudotime") +
  theme_minimal()

condition_ca <-ggplot(umap_ca_df, aes(x = Multiumap_1, y = Multiumap_2, color = pseudotime)) +
    geom_point(size = 1) +
    scale_color_viridis_c(na.value = "grey50") +
    facet_wrap(~ sample) +  # adjust "condition" as needed
    labs(title = "Pseudotime by Condition",
         x = "UMAP 1", y = "UMAP 2") +
    theme_minimal()

pseudo_dg <- ggplot(umap_dg_df, aes(x = Multiumap_1, y = Multiumap_2, color = pseudotime)) +
  geom_point(size = 1) +
  scale_color_viridis_c(na.value = "grey50") +
  labs(title = "Pseudotime Trajectory (Slingshot)",
       color = "Pseudotime") +
  theme_minimal()

condition_dg <-ggplot(umap_dg_df, aes(x = Multiumap_1, y = Multiumap_2, color = pseudotime)) +
    geom_point(size = 1) +
    scale_color_viridis_c(na.value = "grey50") +
    facet_wrap(~ sample) +  # adjust "condition" as needed
    labs(title = "Pseudotime by Condition",
         x = "UMAP 1", y = "UMAP 2") +
    theme_minimal()

# save
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/combined.png", plot = pseudo, width = 12, height = 12, dpi = 300)
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/grouped.png", plot = condition, width = 12, height = 12, dpi = 300)
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/combined_ca.png", plot = pseudo_ca, width = 12, height = 12, dpi = 300)
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/grouped_ca.png", plot = condition_ca, width = 12, height = 12, dpi = 300)
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/combined_dg.png", plot = pseudo_dg, width = 12, height = 12, dpi = 300)
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/grouped_dg.png", plot = condition_dg, width = 12, height = 12, dpi = 300)

# density plot
density <- ggplot(umap_df, aes(x = pseudotime, color = sample, fill = sample)) +
    geom_density(alpha = 0.3) +
    labs(title = "Pseudotime Density by Time Point", x = "Pseudotime", y = "Density") +
    theme_minimal() +
    scale_color_viridis_d() +
    scale_fill_viridis_d()

density_ca <- ggplot(umap_ca_df, aes(x = pseudotime, color = sample, fill = sample)) +
    geom_density(alpha = 0.3) +
    labs(title = "Pseudotime Density by Time Point", x = "Pseudotime", y = "Density") +
    theme_minimal() +
    scale_color_viridis_d() +
    scale_fill_viridis_d()

density_dg <- ggplot(umap_dg_df, aes(x = pseudotime, color = sample, fill = sample)) +
    geom_density(alpha = 0.3) +
    labs(title = "Pseudotime Density by Time Point", x = "Pseudotime", y = "Density") +
    theme_minimal() +
    scale_color_viridis_d() +
    scale_fill_viridis_d()

# bar plot
bar <- ggplot(umap_df, aes(x = sample, y = pseudotime, fill = sample)) +
    geom_boxplot() +
    geom_jitter(width = 0.2, alpha = 0.5) +
    labs(title = "Pseudotime Distribution by Time Point", x = "Time", y = "Pseudotime") +
    theme_minimal() +
    scale_fill_viridis_d()

bar_ca <- ggplot(umap_ca_df, aes(x = sample, y = pseudotime, fill = sample)) +
    geom_boxplot() +
    geom_jitter(width = 0.2, alpha = 0.5) +
    labs(title = "Pseudotime Distribution by Time Point", x = "Time", y = "Pseudotime") +
    theme_minimal() +
    scale_fill_viridis_d()

bar_dg <- ggplot(umap_dg_df, aes(x = sample, y = pseudotime, fill = sample)) +
    geom_boxplot() +
    geom_jitter(width = 0.2, alpha = 0.5) +
    labs(title = "Pseudotime Distribution by Time Point", x = "Time", y = "Pseudotime") +
    theme_minimal() +
    scale_fill_viridis_d()

# save
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/density.png", plot = density, width = 12, height = 12, dpi = 300)
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/bar.png", plot = bar, width = 12, height = 12, dpi = 300)
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/density_ca.png", plot = density_ca, width = 12, height = 12, dpi = 300)
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/bar_ca.png", plot = bar_ca, width = 12, height = 12, dpi = 300)
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/density_dg.png", plot = density_dg, width = 12, height = 12, dpi = 300)
ggsave(filename = "~/PTZ_ATAC_scRNA_072024/WIP/0428_run/Filtered_50_cells/Trajectory/bar_dg.png", plot = bar_dg, width = 12, height = 12, dpi = 300)

```

```{r Trend analysis, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}
# Subset the data by condition
ptz <- subset(hp_subset, subset = condition == "PTZ")
sal <- subset(hp_subset, subset = condition == "SAL")

# For PTZ
cell_names_ptz <- rownames(ptz@meta.data)
#colnames(ptz[['RNA']]@layers$counts) <- cell_names_ptz

# For SAL
cell_names_sal <- rownames(sal@meta.data)
#colnames(sal[['RNA']]@layers$counts) <- cell_names_sal

# Extract UMAP embeddings from each subset
ptz_umap <- Embeddings(ptz, "Multi_umap")
sal_umap <- Embeddings(sal, "Multi_umap")

# Extract cluster/cell type labels
ptz_clusters <- ptz$Cell_type_by_multimodal
sal_clusters <- sal$Cell_type_by_multimodal

# For PTZ subset
ptz_lineages <- slingshot(ptz_umap, clusterLabels = ptz_clusters)

# Extract pseudotime from the first (or only) lineage as a vector
ptz_pt <- slingPseudotime(ptz_lineages)[, 1]  # Should be a numeric vector of length equal to number of PTZ cells

# For SAL subset
sal_lineages <- slingshot(sal_umap, clusterLabels = sal_clusters)

# Extract pseudotime from the first (or only) lineage as a vector
sal_pt <- slingPseudotime(sal_lineages)[, 1]  # Similarly, one pseudotime value per SAL cell

# Optional: Check summaries
summary(ptz_pt)
summary(sal_pt)

# Extract full counts from the RNA assay of the PTZ subset.
# (Using slot "counts" from the "RNA" assay)
full_counts_ptz <- as.matrix(GetAssayData(ptz, assay = "RNA", slot = "counts"))

# Assign cell names from metadata
colnames(full_counts_ptz) <- cell_names_ptz

# Retrieve gene names
gene_names_ptz <- rownames(full_counts_ptz)
cell_names_ptz <- rownames(ptz@meta.data)

# Gene names should be present already; if not, try:
# rownames(full_counts_ptz) <- gene_names_ptz 

# Create the SCE object
sce_ptz <- SingleCellExperiment(assays = list(counts = full_counts_ptz))

# Attach pseudotime (make sure length matches number of cells)
colData(sce_ptz)$pseudotime <- ptz_pt

# Create cellWeights: one weight per cell
cellWeights_ptz <- matrix(1, nrow = ncol(sce_ptz), ncol = 1)

# Extract full counts from the SAL subset
full_counts_sal <- as.matrix(GetAssayData(sal, assay = "RNA", slot = "counts"))

# Assign cell names from SAL meta.data
colnames(full_counts_sal) <- cell_names_sal

# Retrieve gene names
gene_names_sal <- rownames(full_counts_sal)
cell_names_sal <- rownames(sal@meta.data)

# Gene names should be present already; if not, try:
# rownames(full_counts_sal) <- gene_names_sal 

# Create the SCE object for SAL
sce_sal <- SingleCellExperiment(assays = list(counts = full_counts_sal))

# Attach SAL pseudotime (ensure length matches ncol(sce_sal))
colData(sce_sal)$pseudotime <- sal_pt

# Create cellWeights for SAL
cellWeights_sal <- matrix(1, nrow = ncol(sce_sal), ncol = 1)

# Subset SCE to first 500 genes (for testing only)
sce_ptz_subset <- sce_ptz[1:500, ]

# Optionally, reduce number of knots to speed up the fit (e.g., 3 instead of 6)
sce_ptz_subset <- fitGAM(counts = counts(sce_ptz_subset),
                         pseudotime = as.matrix(colData(sce_ptz_subset)$pseudotime),
                         cellWeights = cellWeights_ptz,
                         nknots = 3,
                         verbose = TRUE)

# Run the association test on the subset
ATres_test_ptz <- associationTest(sce_ptz_subset)
head(ATres_test_ptz)

# Subset SCE to first 500 genes (for testing only)
sce_sal_subset <- sce_sal[1:500, ]

# Optionally, reduce number of knots to speed up the fit (e.g., 3 instead of 6)
sce_sal_subset <- fitGAM(counts = counts(sce_sal_subset),
                         pseudotime = as.matrix(colData(sce_sal_subset)$pseudotime),
                         cellWeights = cellWeights_sal,
                         nknots = 3,
                         verbose = TRUE)

# Run the association test on the subset
ATres_test_sal <- associationTest(sce_sal_subset)
head(ATres_test_sal)

# Fit tradeSeq models for PTZ
sce_ptz <- fitGAM(counts = counts(sce_ptz),
                  pseudotime = as.matrix(colData(sce_ptz)$pseudotime), 
                  cellWeights = cellWeights_ptz,
                  nknots = 6,
                  verbose = TRUE)

# Fit tradeSeq models for SAL
sce_sal <- fitGAM(counts = counts(sce_sal),
                  pseudotime = as.matrix(colData(sce_sal)$pseudotime),
                  cellWeights = cellWeights_sal,
                  nknots = 6,
                  verbose = TRUE)

# Test for genes with dynamic expression over pseudotime
ATres_ptz <- associationTest(sce_ptz)
ATres_sal <- associationTest(sce_sal)
head(ATres_ptz)
head(ATres_sal)

# Pick out the top 250 genes based on p-value
topgenes_ptz <- rownames(ATres_ptz[order(ATres_ptz$pvalue), ])
topgenes_sal <- rownames(ATres_sal[order(ATres_sal$pvalue), ])

# Order the cells by pseudotime
pst.ord_ptz <- order(colData(sce_ptz)$pseudotime, na.last = NA)
pst.ord_sal <- order(colData(sce_sal)$pseudotime, na.last = NA)

# Extract the counts for the top genes for cells ordered by pseudotime
heatdata_ptz <- assays(sce_ptz)$counts[topgenes_ptz, pst.ord_ptz]
heatdata_sal <- assays(sce_sal)$counts[topgenes_sal, pst.ord_sal]

# Plot the heatmap of log-transformed counts
heat_ptz <- pheatmap(log1p(heatdata_ptz), cluster_cols = FALSE, main = "Top 250 Dynamically Expressed Genes_PTZ")

heat_sal <- pheatmap(log1p(heatdata_sal), cluster_cols = FALSE, main = "Top 250 Dynamically Expressed Genes_SAL")

# per gene
plotSmoothers(sce_ptz, counts = counts(sce_ptz), gene = "GeneX", ncol = 1) +     ggtitle("GeneX Expression Trend in PTZ")
plotSmoothers(sce_sal, counts = counts(sce_sal), gene = "GeneX", ncol = 1) +     ggtitle("GeneX Expression Trend in SAL")
``` 

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```

```{r, echo=TRUE, error=TRUE, message=TRUE, warning=TRUE}

```


